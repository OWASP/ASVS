{
  "Name": "Application Security Verification Standard Project",
  "ShortName": "ASVS",
  "Version": "5.0.0",
  "Description": "The OWASP Application Security Verification Standard (ASVS) Project provides a basis for testing web application technical security controls and also provides developers with a list of requirements for secure development.",
  "Requirements": [
    {
      "Shortcode": "V1",
      "Ordinal": 1,
      "ShortName": "Encoding",
      "Name": "인코딩과 데이터 정제",
      "Items": [
        {
          "Shortcode": "V1.1",
          "Ordinal": 1,
          "Name": "인코딩 및 데이터 정제 아키텍처",
          "Items": [
            {
              "Shortcode": "V1.1.1",
              "Ordinal": 1,
              "Description": "입력값 검증은 오직 한 번만 표준 형태로 디코딩 되거나 언이스케이프 되어야 하며, 인코딩된 데이터가 예상될 때만 디코딩 되어야 한다. 이 과정은 입력이 추가로 처리되기 전에 완료되어야 한다. 예를 들어서 입력값 검증이나 데이터 정제 이후에는 수행되면 안 된다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.1.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 출력값 인코딩 또는 이스케이핑을 인터프리터가 사용하기 전의 최종 단계로 수행하거나 인터프리터 자체에서 처리하는지 검증해야 한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V1.2",
          "Ordinal": 2,
          "Name": "인젝션(Injection) 방지",
          "Items": [
            {
              "Shortcode": "V1.2.1",
              "Ordinal": 1,
              "Description": "HTTP 응답, HTML 문서 또는 XML 문서에 대한 출력값 인코딩이 해당 컨텍스트에 적절한지 검증해야 한다. 예를 들어, 메시지나 문서 구조가 변경되지 않도록 HTML 요소, HTML 속성, HTML 주석, CSS, HTTP 헤더 필드 등에 맞는 문맥별 문자 인코딩이 수행되어야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V1.2.2",
              "Ordinal": 2,
              "Description": "통합 자원 식별자(Uniform Resource Locator; URL)들을 동적으로 생성할 때 신뢰할 수 없는 데이터가 해당 컨텍스트에 맞게 인코딩되었는지 검증해야 한다(예: 쿼리나 경로 파라미터에 대한 URL 인코딩 또는 base64url 인코딩). 또한, 오직 안전한 URL 프로토콜만이 허용되는지 검증해야 한다(예: javascript: 또는 data:를 허용하지 않음).",
              "L": "1"
            },
            {
              "Shortcode": "V1.2.3",
              "Ordinal": 3,
              "Description": "동적으로 자바스크립트 콘텐츠(JSON 포함)를 생성할 때 메시지나 문서 구조를 바꾸는 것을 방지하기 위해 출력값 인코딩이나 이스케이핑이 사용되고 있는지 검증해야 한다(자바스크립트 또는 JSON 인젝션을 피하기 위함).",
              "L": "1"
            },
            {
              "Shortcode": "V1.2.4",
              "Ordinal": 4,
              "Description": "데이터 선택 혹은 데이터베이스 쿼리(예: SQL, HQL, NoSQL, Cypher)들 파라미터화된 쿼리, 객체 관계 매핑(Object Relational Mapping; ORM), 엔티티 프레임워크, 또는 다른 구조화된 쿼리 언어(Structured Query Language; SQL) 인젝션 및 기타 데이터베이스 인젝션 공격으로부터 보호해 주는 것들을 사용하는지 검증해야 한다. 이는 저장 프로시저를 쓸 때도 마찬가지이다.",
              "L": "1"
            },
            {
              "Shortcode": "V1.2.5",
              "Ordinal": 5,
              "Description": "애플리케이션이 운영체제(Operating System; OS) 명령 인젝션으로부터 보호되며 운영체제 호출 시 파라미터화된 OS 쿼리나 상황에 맞는 명령줄 출력값 인코딩을 사용하는지 검증해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V1.2.6",
              "Ordinal": 6,
              "Description": "애플리케이션이 경량 디렉터리 접근 프로토콜(Lightweight Directory Access Protocol; LDAP) 인젝션 취약점에 대해 보호되어 있는지, 또는 LDAP 인젝션을 방지하기 위한 특정 보안 통제가 구현되어 있는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.2.7",
              "Ordinal": 7,
              "Description": "애플리케이션이 XPath 인젝션 공격을 쿼리 파라미터나 미리 컴파일된 쿼리들을 사용해 보호되고 있는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.2.8",
              "Ordinal": 8,
              "Description": "LaTeX 프로세서가 안전하게 구성되어 있으며(\"--shell-escape\" 플래그 비사용 등) LaTeX 인젝션 공격을 방지하기 위해 허용된 명령어 목록이 사용되고 있는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.2.9",
              "Ordinal": 9,
              "Description": "애플리케이션이 정규 표현식에서 특수 문자들을 메타 문자로 잘못 해석하는 것을 방지하기 위해 해당 문자들 이스케이프(보통 백슬래시를 사용)하고 있는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.2.10",
              "Ordinal": 10,
              "Description": "애플리케이션이 쉼표 구분 데이터(Comma Separated Values; CSV) 및 수식 인젝션에 대해 보호되어 있는지 검증해야 한다. 그리고 애플리케이션은 CSV 콘텐츠를 내보낼 때 RFC 4180 2.6과 2.7 부분에 명시된 이스케이핑 규칙을 반드시 따라야 한다. 또한 CSV나 다른 스프레드시트 포맷(XLS, XLSX, ODF 등)으로 내보낼 때 필드 값의 첫 번째가 특수 문자('=', '+', '-', '@', '\\t' (탭), '\\0' (null 문자) 포함)라면 반드시 작은따옴표로 이스케이프되어야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V1.3",
          "Ordinal": 3,
          "Name": "데이터 정제",
          "Items": [
            {
              "Shortcode": "V1.3.1",
              "Ordinal": 1,
              "Description": "위지윅(WYSIWYG) 에디터나 이와 유사한 것으로부터 오는 모든 신뢰할 수 없는 HTML 입력들은 잘 알려지고 안전한 HTML 데이터 정제 라이브러리나 프레임워크 기능을 사용해 정제되는지 검증해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V1.3.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 eval() 또는 스프링 표현 언어(Spring Expression Language; SpEL) 등과 같은 동적 코드 실행 기능 사용을 피하고 있는지 검증해야 한다. 대안이 없는 경우, 실행 전에 포함되는 모든 사용자 입력이 반드시 정제되어야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V1.3.3",
              "Ordinal": 3,
              "Description": "잠재적으로 위험한 컨텍스트에 전달되는 데이터가 사전에 정제되어 안전 조치가 적용되는지 검증해야 한다. 예를 들어 해당 컨텍스트에서 안전한 문자만 허용하고 너무 긴 입력값은 잘라내는 등의 조치가 포함된다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.3.4",
              "Ordinal": 4,
              "Description": "사용자로부터 제공된 확장 가능한 벡터 그래픽(Scalable Vector Graphics; SVG)의 스크립트 실행 가능 콘텐츠가 애플리케이션에 안전한 태그 및 속성(예: 그래픽 그리기)만 포함하도록 검증 또는 정제되는지 검증해야 한다. 예를 들어 스크립트나 foreignObject는 포함되면 안 된다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.3.5",
              "Ordinal": 5,
              "Description": "애플리케이션이 사용자로부터 제공된 스크립트 실행 가능하거나 표현식 템플릿 언어(예: 마크다운, CSS, XSL 스타일시트, BBCode ) 콘텐츠를 정제하거나 비활성화하는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.3.6",
              "Ordinal": 6,
              "Description": "애플리케이션이 서버측 요청 위조(Server-side Request Forgery; SSRF) 공격으로부터 보호하기 위해 신뢰할 수 없는 데이터를 프로토콜, 도메인, 경로, 포트의 허용 목록과 대조해 검증하고 다른 서비스를 호출하기 전에 잠재적으로 위험한 문자를 정제(sanitization)하는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.3.7",
              "Ordinal": 7,
              "Description": "애플리케이션이 템플릿 인젝션 공격으로부터 보호하기 위해 신뢰할 수 없는 입력값을 기반으로 템플릿을 생성하지 않도록 하는지 검증해야 한다. 대안이 없는 경우에는 템플릿 생성 과정에서 동적으로 포함되는 모든 신뢰할 수 없는 입력값은 정제되거나 엄격히 검증되어야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.3.8",
              "Ordinal": 8,
              "Description": "애플리케이션이 자바 명명 및 디렉터리 인터페이스(Java Naming and Directory Interface; JNDI) 쿼리에서 신뢰할 수 없는 입력값을 사용하기 전에 적절히 정제하고 JNDI가 JNDI 인젝션 공격을 방지할 수 있도록 안전하게 구성되어 있는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.3.9",
              "Ordinal": 9,
              "Description": "인젝션을 방지하기 위해 애플리케이션이 메모리 캐시(memcache)에 콘텐츠를 전달하기 전에 해당 데이터를 정제하는지 검증해야 한다. ",
              "L": "2"
            },
            {
              "Shortcode": "V1.3.10",
              "Ordinal": 10,
              "Description": "사용 시 예상치 못하거나 악의적인 방식으로 작동할 수 있는 포맷 스트링(format string)들은 처리되기 전에 정제되는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.3.11",
              "Ordinal": 11,
              "Description": "간이 전자 우편 전송 프로토콜(Simple Mail Transfer Protocol; SMTP)이나 인터넷 메시지 액세스 프로토콜(Internet Message Access Protocol; IMAP) 인젝션으로부터 보호하기 위해 애플리케이션이 사용자 입력을 메일 시스템으로 보내기 전에 정제를 하는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.3.12",
              "Ordinal": 12,
              "Description": "정규 표현식에 지수형 백트래킹을 유발하는 요소가 없는지, 또한 신뢰할 수 없는 입력값을 정제하여 정규식 기반 서비스 거부 공격(Regular Expression Denial of Service; ReDoS) 또는 런어웨이(Runaway) 정규식 공격을 방지하는지 검증해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V1.4",
          "Ordinal": 4,
          "Name": "메모리, 스트링, 비관리 코드",
          "Items": [
            {
              "Shortcode": "V1.4.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 스택, 버퍼, 또는 힙 오버플로를 탐지하거나 방지하기 위해 메모리 안전 문자열, 안전한 메모리 복사 및 포인터 산술을 사용하는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.4.2",
              "Ordinal": 2,
              "Description": "정수 오버플로를 방지하기 위해 부호 확인, 범위 검사, 입력값 검증 등의 기법이 사용되고 있는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.4.3",
              "Ordinal": 3,
              "Description": "댕글링 포인터(dangling pointer)나 해체 후 사용(Use After Free; UAF) 취약점을 방지하기 위해 동적으로 할당된 메모리와 자원이 적절히 해제되었는지 그리고 해제된 메모리를 참조하는 포인터나 참조가 제거되었거나 null로 설정되었는지를 검증해야 한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V1.5",
          "Ordinal": 5,
          "Name": "안전한 역직렬화",
          "Items": [
            {
              "Shortcode": "V1.5.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 확장 가능한 마크업 언어(eXtensible Markup Language; XML) 파서(parser)를 제한적인 설정으로 구성하고 외부 엔티티 해석과 같은 안전하지 않은 기능을 비활성화하여 XML 외부 엔티티(XML eXternal Entity; XXE) 공격을 방지하는지 검증해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V1.5.2",
              "Ordinal": 2,
              "Description": "역직렬화 공격을 방지하기 위해 신뢰할 수 없는 데이터의 역직렬화 시 객체 타입 허용 목록 사용 또는 클라이언트 정의 객체 타입 제한과 같은 안전한 입력 처리 방식이 적용되는지 검증해야 한다. 또한 명확히 안전하지 않은 것으로 지정된 역직렬화 메커니즘은 신뢰할 수 없는 입력에 대해 반드시 사용해서는 안 된다.",
              "L": "2"
            },
            {
              "Shortcode": "V1.5.3",
              "Ordinal": 3,
              "Description": "애플리케이션에서 동일한 데이터 타입(예: JSON 파서, XML 파서, URL 파서)에 대해 사용되는 서로 다른 파서들이 일관된 방식으로 파싱(parsing)을 수행하고 동일한 문자 인코딩 방식을 사용하는지 검증해야 한다. 이를 통해 JSON 상호운용 취약점이나 원격 파일 포함(Remote File Inclusion; RFI) 및 SSRF 공격에서 악용될 수 있는 서로 다른 URI 또는 파일 파싱 동작 문제를 방지할 수 있다.",
              "L": "3"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V2",
      "Ordinal": 2,
      "ShortName": "Validation",
      "Name": "유효성 검증 및 비즈니스 로직",
      "Items": [
        {
          "Shortcode": "V2.1",
          "Ordinal": 1,
          "Name": "유효성 검증 및 비즈니스 로직 문서화",
          "Items": [
            {
              "Shortcode": "V2.1.1",
              "Ordinal": 1,
              "Description": "애플리케이션 문서에 데이터 항목이 예상되는 구조에 부합하는지 확인하는 입력값 유효성 검증 규칙이 정의되어 있는지 확인한다. 이는 신용카드 번호, 이메일 주소, 전화번호와 같은 일반적인 데이터 형식일 수도 있고, 내부적으로 사용하는 데이터 형식일 수도 있다.",
              "L": "1"
            },
            {
              "Shortcode": "V2.1.2",
              "Ordinal": 2,
              "Description": "애플리케이션 문서에 연관된 데이터 항목들 간의 논리적, 문맥적 일관성을 검증하는 방법이 정의되어 있는지 검증한다. 예를 들어서 세부 주소와 우편번호가 서로 일치하는지 확인하는 경우가 이에 해당한다.",
              "L": "2"
            },
            {
              "Shortcode": "V2.1.3",
              "Ordinal": 3,
              "Description": "비즈니스 로직의 제한사항 및 유효성 검증에 대한 요구사항이 사용자별 기준과 애플리케이션 전체에 적용되는 전역적 기준을 모두 포함하여 문서화되어 있는지 검증한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V2.2",
          "Ordinal": 2,
          "Name": "입력값 검증",
          "Items": [
            {
              "Shortcode": "V2.2.1",
              "Ordinal": 1,
              "Description": "입력값에 대한 비즈니스 또는 기능적인 기대치를 충족하기 위해서 입력값의 유효성을 검증해야 한다. 이는 허용 값, 패턴 및 범위 목록에 대한 긍정적 검증을 사용하거나, 미리 정의된 규칙에 따라 입력값을 예상 구조 및 논리적 한계와 비교하여 검증해야 한다. L1의 경우, 특정 비즈니스 또는 보안 결정을 내리는 데 초점을 맞출 수 있다. L2 이상의 경우에는 모든 입력값에 적용해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V2.2.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 신뢰할 수 있는 서비스 계층에서 입력값 유효성 검사를 시행하도록 설계되었는지 확인해야 한다. 클라이언트 측 유효성 검사는 사용성을 향상시키므로 권장해야 하지만, 보안 제어 수단으로 의존해서는 안된다.",
              "L": "1"
            },
            {
              "Shortcode": "V2.2.3",
              "Ordinal": 3,
              "Description": "사전 정의된 규칙에 따라 관련 데이터 항목의 조합이 합리적인지 애플리케이션에서 확인해야 한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V2.3",
          "Ordinal": 3,
          "Name": "비즈니스 로직 보안",
          "Items": [
            {
              "Shortcode": "V2.3.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 예상되는 순차적 단계 순서에 따라 동일한 사용자에 대한 비즈니스 로직 흐름만 처리하고 단계를 건너뛰지 않는지 확인한다.",
              "L": "1"
            },
            {
              "Shortcode": "V2.3.2",
              "Ordinal": 2,
              "Description": "비즈니스 로직 결함이 악용되는 것을 방지하기 위해서 애플리케이션 문서에 따라 비즈니스 로직 제한이 구현되었는지 확인한다.",
              "L": "2"
            },
            {
              "Shortcode": "V2.3.3",
              "Ordinal": 3,
              "Description": "비즈니스 로직 수준에서 트랜잭션이 사용되고 있는지 확인하여 비즈니스 로직 작업이 완전히 성공하거나 이전의 올바른 상태로 롤백되는지 확인한다.",
              "L": "2"
            },
            {
              "Shortcode": "V2.3.4",
              "Ordinal": 4,
              "Description": "제한된 양의 리소스(ex. 극장 좌석이나 배송 시간대)가 애플리케이션의 로직을 조작하여 이중으로 예약되는 것을 방지하기 위해서 비즈니스 로직 수준 잠금 메커니즘이 사용되는지 확인한다.",
              "L": "2"
            },
            {
              "Shortcode": "V2.3.5",
              "Ordinal": 5,
              "Description": "핵심적인 비즈니스 로직 흐름에 무단 또는 우발적인 행위를 방지하기 위해서 다중 사용자 승인이 필요한지 확인해야 한다. 이는 거액 자금 이체, 계약 승인, 기밀 정보 접근, 제조 과정의 안전 무시 등이 포함될 수 있지만, 이에 국한되지는 않는다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V2.4",
          "Ordinal": 4,
          "Name": "자동화 방지",
          "Items": [
            {
              "Shortcode": "V2.4.1",
              "Ordinal": 1,
              "Description": "데이터 유출, 더미 데이터 생성, 할당량 소진, 속도 제한 위반, 서비스 거부(DoS), 핵심적인 리소스의 과다 사용으로 이어질 수 있는 애플리케이션 기능에 대한 과도한 호출을 방어하기 위해, 자동화 방지 제어 기능이 구현되어 있는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V2.4.2",
              "Ordinal": 2,
              "Description": "비즈니스 로직의 각 단계가 실제 사람이 수행하는 데 필요한 현실적인 시간을 요구하여, 비정상적으로 빠른 속도의 트랜잭션 제출을 방지하는지 검증한다.",
              "L": "3"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V3",
      "Ordinal": 3,
      "ShortName": "Web",
      "Name": "웹 프론트엔드 보안",
      "Items": [
        {
          "Shortcode": "V3.1",
          "Ordinal": 1,
          "Name": "웹 프론트엔드 보안 문서",
          "Items": [
            {
              "Shortcode": "V3.1.1",
              "Ordinal": 1,
              "Description": "애플리케이션 공식 문서에서 애플리케이션이 반드시 지원해야 하는, 예상되는 보안 특징들을 서술하고 있는지 확인한다. (예: HTTPS, HTTP Strict Transport Security (HSTS), Content Security Policy (CSP), 그리고 다른 관련된 HTTP 보안 메커니즘들). 또한 문서에서 앞선 특징들(유저에게나 경고하거나 접속을 막는 등의)이 유효하지 않을 때 애플리케이션이 어떻게 행동하는지 반드시 정의해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V3.2",
          "Ordinal": 2,
          "Name": "의도하지 않은 콘텐츠 접근",
          "Items": [
            {
              "Shortcode": "V3.2.1",
              "Ordinal": 1,
              "Description": "브라우저가 HTTP 응답에 대해 콘텐츠나 기능을 불러올 때, 의도하지 않은 상황이 보안적으로 통제되고 있는지 확인한다(예: API, 유저가 올린 파일, 혹은 다른 리소스에 직접 접근 시). Content-Security-Policy 헤더 필드의 샌드박스 지시어를 사용하거나, Content-Disposition 헤더 필드 내의 attachment disposition 타입을 사용하는 등으로, 불필요한 HTTP 요청 헤더 필드 (Sec-Fetch-* 와 같은)를 제공하지 않을 수 있다.",
              "L": "1"
            },
            {
              "Shortcode": "V3.2.2",
              "Ordinal": 2,
              "Description": "콘텐츠가 HTML로 렌더링되지 않고 텍스트로 표시되도록 하여, HTML이나 JavaScript 등의 의도하지 않은 실행을 방지하는 안전한 렌더링 함수(예: createTextNode, textContent)를 사용하는지 확인한다.",
              "L": "1"
            },
            {
              "Shortcode": "V3.2.3",
              "Ordinal": 3,
              "Description": "애플리케이션이 클라이언트 사이드 JavaScript를 사용할 때, 명시적 변수 사용, 엄격한 타입 검사, 문서에서의 전역 변수 저장 지양, 그리고 네임스페이스 격리 구현 등으로 DOM 클로버링을 막고 있음을 확인한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V3.3",
          "Ordinal": 3,
          "Name": "쿠키 설정",
          "Items": [
            {
              "Shortcode": "V3.3.1",
              "Ordinal": 1,
              "Description": "쿠키가 'Secure' 속성을 가지며, 쿠키 이름에 '\\__Host-' 접두사가 사용되지 않았고, '__Secure-' 접두사를 사용했는지 확인한다.",
              "L": "1"
            },
            {
              "Shortcode": "V3.3.2",
              "Ordinal": 2,
              "Description": "UI redress 공격, 그리고 CSRF라 알려진 브라우저 기반 요청 위조 공격들에 대한 노출을 제한하기 위해 각 쿠키의 'SameSite' 속성 값이 쿠키의 목적에 맞게 설정되어 있는지 확인한다.",
              "L": "2"
            },
            {
              "Shortcode": "V3.3.3",
              "Ordinal": 3,
              "Description": "다른 호스트들과 명시적으로 공유되는 쿠키에 대해서, '__Host-' 접두사를 가지고 있는지 확인한다.",
              "L": "2"
            },
            {
              "Shortcode": "V3.3.4",
              "Ordinal": 4,
              "Description": "클라이언트 측 스크립트에서 쿠키의 값에 접근이 가능한 걸 의도하지 않았다면(세션 토큰 등), 쿠키는 반드시 'HttpOnly' 속성을 가져야 하고, 반드시 'Set-Cookie' 헤더 필드를 통해 클라이언트에게 전달돼야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V3.3.5",
              "Ordinal": 5,
              "Description": "애플리케이션이 쿠키를 만들 때, 쿠키 이름과 값의 길이 합이 4096바이트를 넘지 않는지 확인한다. 너무 큰 쿠키는 브라우저에 저장되지 않으며, 요청 전달도 안되고, 해당 쿠키에 의존하는 애플리케이션 기능을 사용하지 못하게 된다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V3.4",
          "Ordinal": 4,
          "Name": "브라우저 보안 메커니즘 헤더",
          "Items": [
            {
              "Shortcode": "V3.4.1",
              "Ordinal": 1,
              "Description": "이 섹션에서는 애플리케이션의 응답을 처리할 때 브라우저의 보안 기능과, 제한 사항을 활성화하기 위해 HTTP 응답에 설정해야 하는 보안 헤더를 설명한다.",
              "L": "1"
            },
            {
              "Shortcode": "V3.4.2",
              "Ordinal": 2,
              "Description": "교차 출처 리소스 공유(CORS)의 Access-Control-Allow-Origin 헤더 필드가 애플리케이션의 고정 값인지 확인한다. 만약 출처 Origin HTTP 요청 헤더 필드 값을 사용하고 있다면, 신뢰할 수 있는 출처 목록으로 검증한다. 'Access-Control-Allow-Origin: *' 사용이 필요할 때엔, 응답이 민감한 정보를 포함하지 않는지 확인한다.",
              "L": "1"
            },
            {
              "Shortcode": "V3.4.3",
              "Ordinal": 3,
              "Description": "HTTP 응답이 Content-Security-Policy 응답 헤더 필드를 가지고 있는지 확인한다. 이는 브라우저가 신뢰하는 콘텐츠나 리소스만 불러오고 실행하도록 하고, 위험한 JavaScript의 실행을 제한한다. 최소한,  object-src 'none' 과 base-uri 'none'이라는 지침, 그리고 허용 목록을 정의하거나 논스, 해쉬의 사용을 포함한다는 전역 정책은 반드시 사용돼야 한다. 3계층 애플리케이션의 경우에는, 논스나 해쉬가 적용된 응답별 정책이 반드시 정의돼야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V3.4.4",
              "Ordinal": 4,
              "Description": "모든 HTTP 응답이 'X-Content-Type-Options: nosniff' 헤더 필드를 포함하는지 확인해야 한다. 이는 브라우저들이 주어진 응답에 대해 콘텐츠 스니핑과 MIME 타입 추측을 하지 않도록, 응답의 Content-Type 헤더 필드 값을 목적지 리소스와 일치하도록 지시한다. 예를 들어서, 응답의 Content-Type이 'text/css'인 스타일만 허용된다고 치자. 이는 기능적으로 브라우저의 Cross-Origin Read Blocking (CORB) 사용 또한 활성화시킨다.",
              "L": "2"
            },
            {
              "Shortcode": "V3.4.5",
              "Ordinal": 5,
              "Description": "'Referer' HTTP 요청 헤더 필드를 통해 제 3자 서비스들에 기술적으로 민감한 정보 누출을 막기 위해, 애플리케이션에서 리퍼러 정책을 설정했는지 확인해야 한다. 이는 Referrer-Policy HTTP 응답 헤더 필드나 HTML 속성 항목을 통해 설정할 수 있다. 민감한 데이터는 URL에 있는 경로나 쿼리 데이터, 그리고 내부 비공개 애플리케이션의 경우 hostname도 포함된다.",
              "L": "2"
            },
            {
              "Shortcode": "V3.4.6",
              "Ordinal": 6,
              "Description": "웹 애플리케이션이 Content-Security-Policy 헤더 필드의 frame-ancestors를 사용해 모든 HTTP 응답들에 대해 기본적으로 내부 삽입을 할 수 없고, 필요할 때만 특정 리소스에 대해 내부 삽입을 허용하도록 확인한다. X-Frame-Options 헤더 필드가 브라우저에서 지원되더라도, 오래돼서 신뢰할 수 없음을 알아야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V3.4.7",
              "Ordinal": 7,
              "Description": "Content-Security-Policy 헤더 필드에 위반 사항을 보고할 영역이 특정되어 있는지 확인해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V3.4.8",
              "Ordinal": 8,
              "Description": "문서 렌더링을 시작하는 모든 HTTP 요청(Content-Type text/html과 같은 응답)에 same-origin 지시어나 same-origin-allow-popups이 있는 Cross‑Origin‑Opener‑Policy 헤더 필드를 포함하는지 확인해야 한다. 이는 탭내빙(tabnabbing) 및 프레임 카운팅과 같은 Window 객체에 대한 공유 액세스를 악용하는 공격을 방지할 수 있다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V3.5",
          "Ordinal": 5,
          "Name": "브라우저 출처 구분",
          "Items": [
            {
              "Shortcode": "V3.5.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 허용되지 않은 교차 출처 요청을 통한 민감한 기능의 사용을 막기 위해 CORS preflight 메커니즘에 의존하지 않는지 확인하고, 이런 요청이 애플리케이션 자체에서 시작된건지 증명해야 한다. 이는 anti-forgery 토큰의 사용과 증명이나 CORS-safelisted 요청 헤더 필드가 아닌 확장 HTTP 헤더 필드를 요구하는 것으로 가능하다. 사이트 간 요청 위조 공격(CSRF)으로 알려진 브라우저 기반의 요청 위조 공격에 대한 방어다.",
              "L": "1"
            },
            {
              "Shortcode": "V3.5.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 민감한 기능의 허용되지 않은 교차 출처 사용을 막기 위해 CORS preflight 메커니즘에 의존하고 있다면, CORS preflight 요청을 작동하지 않는 요청을 호출할 수 있는지 확인해야 한다. 이는 'Origin'과 'Content-Type' 요청 헤더 필드 값을 확인하거나 CORS-safelisted 헤더 필드가 아닌 확장 필드 사용에 대한 확인이 필요하다.",
              "L": "1"
            },
            {
              "Shortcode": "V3.5.3",
              "Ordinal": 3,
              "Description": "민감한 기능이 HTTP 요청으로 POST, PUT, PATCH, DELETE와 같은 적절한 HTTP 방식을 사용하는지, HEAD, OPTIONS, 또는 GET처럼 HTTP 사양이 \"안전\"으로 정의되지 않는 방식을 사용하는지 확인한다. 또는 Sec-Fetch-* 요청 헤더 필드의 엄격한 검증을 사용하여 요청이 부적절한 교차 출처 호출, 탐색 요청 또는 이미지 소스와 같은 리소스 로드에서 발생하지 않았는지 확인할 수 있다.",
              "L": "1"
            },
            {
              "Shortcode": "V3.5.4",
              "Ordinal": 4,
              "Description": "서로 다른 호스트 이름에 별도의 애플리케이션이 호스팅되어 있는지 확인하여 동일한 출처 정책에서 제공하는 제한 사항을 활용한다. 여기에는 한 출처에서 불러온 문서나 스크립트가 다른 출처의 리소스와 상호 작용할 수 있는 방법과 쿠키에서의 호스트 이름 기반 제한 사항이 포함된다.",
              "L": "2"
            },
            {
              "Shortcode": "V3.5.5",
              "Ordinal": 5,
              "Description": "postMessage 인터페이스를 통해 수신한 메시지의 출처를 신뢰할 수 없거나, 구문이 유효하지 않은 경우, 수신한 메시지가 폐기되는지 확인한다.",
              "L": "2"
            },
            {
              "Shortcode": "V3.5.6",
              "Ordinal": 6,
              "Description": "Cross-Site Script Inclusion (XSSI) 공격을 피하기 위해, 애플리케이션 아무 곳에서나 JSONP 기능이 활성화되지 않는지 확인한다.",
              "L": "3"
            },
            {
              "Shortcode": "V3.5.7",
              "Ordinal": 7,
              "Description": "Cross-Site Script Inclusion (XSSI) 공격을 방지하기 위해 JavaScript 파일과 같은 스크립트 리소스 응답에 승인이 필요한 데이터가 포함되지 않았는지 확인한다.",
              "L": "3"
            },
            {
              "Shortcode": "V3.5.8",
              "Ordinal": 8,
              "Description": "인증된 리소스(예: 이미지, 비디오, 스크립트 및 기타 문서)가 의도된 경우에만 사용자를 대신하여 불러와지거나 내장될 수 있는지 확인한다. 이는 Sec-Fetch-* HTTP 요청 헤더 필드를 엄격하게 검증하여 요청이 부적절한 교차 출처 호출에서 발생하지 않았는지 확인하거나 브라우저에 반환된 콘텐츠를 차단하도록 지시하는 제한적인 교차 출처 리소스 정책 HTTP 응답 헤더 필드를 설정하여 달성할 수 있다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V3.6",
          "Ordinal": 6,
          "Name": "외부 리소스 무결성",
          "Items": [
            {
              "Shortcode": "V3.6.1",
              "Ordinal": 1,
              "Description": "클라이언트 측 자산(예: JavaScript 라이브러리, CSS 또는 웹 폰트)이 정적이고 버전이 지정된 경우에만 외부(예: 콘텐츠 전송 네트워크)로만 호스팅되는지 확인하고, 하위 리소스 무결성(SRI)을 사용하여 자산의 무결성을 검증한다. 이것이 불가능하다면 각 리소스에 대해 이를 정당화하기 위해 문서화된 보안 결정이 필요하다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V3.7",
          "Ordinal": 7,
          "Name": "다른 브라우저 보안 고려사항",
          "Items": [
            {
              "Shortcode": "V3.7.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 여전히 지원되고 안전하다고 간주되는 클라이언트 측 기술만 사용하는지 확인한다. 이 요구 사항을 충족하지 않는 기술의 예로는 NSAPI 플러그인, Flash, Shockwave, ActiveX, Silverlight, NACL 또는 클라이언트 측 Java applets가 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V3.7.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 사용자를 통제하지 못하는 다른 호스트 이름이나 도메인으로 자동으로 리다이렉션할 때, 허용된 목적지로만 리다이렉션 하는지 확인한다.",
              "L": "2"
            },
            {
              "Shortcode": "V3.7.3",
              "Ordinal": 3,
              "Description": "사용자가 애플리케이션의 통제 범위를 벗어난 URL로 리다이렉션 될 때 이를 취소할 수 있는 옵션이 있는 알림이 애플리케이션에 표시되는지 확인한다.",
              "L": "3"
            },
            {
              "Shortcode": "V3.7.4",
              "Ordinal": 4,
              "Description": "애플리케이션의 최상위 도메인(예: site.tld)가 공공 HSTS preload 목록에 추가되었는지 확인한다. 이렇게 하면 애플리케이션에 TLS를 사용하는 것이 Strict-Transport-Security 응답 헤더 필드에만 의존하지 않고 메인 브라우저에 직접 내장된다.",
              "L": "3"
            },
            {
              "Shortcode": "V3.7.5",
              "Ordinal": 5,
              "Description": "애플리케이션에 접근하는 브라우저가 예상한 보안 특징을 가지고 있지 않은 경우, 애플리케이션이 문서에 명시된 대로 동작하는지 확인한다 (유저에게 경고하거나 접근을 차단하는 등).",
              "L": "3"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V4",
      "Ordinal": 4,
      "ShortName": "API",
      "Name": "API 와 WEB 서비스",
      "Items": [
        {
          "Shortcode": "V4.1",
          "Ordinal": 1,
          "Name": "일반적인 웹 서비스 보안",
          "Items": [
            {
              "Shortcode": "V4.1.1",
              "Ordinal": 1,
              "Description": "메세지 본문이 포함된 모든 HTTP 응답에는 실제 내용과 일치하는 Content-Type 헤더 필드가 포함되어 있는지 검증한다. 이때 IANA 미디어 타입(text, /+xml, /xml 등)에 따라 안전한 문자 인코딩 (ex. UTF-8, ISO-8859-1)을 지정하는 charset 파라미터도 포함되어야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V4.1.2",
              "Ordinal": 2,
              "Description": "사용자가 대면하는 엔드포인트(사람이 직접 웹 브라우저에 접속하는 경우)만 HTTP에서 HTTPS로 자동 리디렉션하고, 그 외에 서비스나 API 엔드포인트는 명백한 리디렉션을 구현하지 않았는지 검증한다. 이는 클라이언트가 실수로 암호화되지 않은 HTTP 요청을 보내고 있음에도, 요청이 자동으로 HTTPS로 리디렉션되어 민감한 데이터의 유출 사실을 발견하지 못하게 되는 상황을 방지하기 위함이다.",
              "L": "2"
            },
            {
              "Shortcode": "V4.1.3",
              "Ordinal": 3,
              "Description": "로드 밸런서, 웹 프록시, 백엔드-프론트엔드 서비스 등 중간 계층에서 설정되며, 애플리케이션에서 사용하는 모든 HTTP 헤더 필드를 사용자가 재정의할 수 없는지 확인한다. 예를 들어 X-Real-IP, X-Frowarded-*, X-User-ID 등의 헤더가 포함될 수 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V4.1.4",
              "Ordinal": 4,
              "Description": "애플리케이션이나 API에서 명시적으로 지원하는 HTTP 메서드(프리플라이트 요청 시에 OPTIONS 포함)만 사용할 수 있으며, 사용되지 않는 메서드는 차단되어 있는지 확인한다.",
              "L": "3"
            },
            {
              "Shortcode": "V4.1.5",
              "Ordinal": 5,
              "Description": "매우 민감하거나 여러 시스템을 거치는 요청이나 거래에 대한 전송 계층 보호에 더하여 메세지별 디지털 서명들을 사용함으로써 추가적인 보증을 제공하는지 확인한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V4.2",
          "Ordinal": 2,
          "Name": "HTTP 메세지 구조 검증",
          "Items": [
            {
              "Shortcode": "V4.2.1",
              "Ordinal": 1,
              "Description": "모든 애플리케이션 구성 요소(로드 밸런서, 방화벽, 애플리케이션 서버 포함)가 HTTP 요청 smuggling을 예방하는 HTTP 버전의 적합한 메커니즘을 사용하는지에 대해, 수신되는 HTTP 메세지의 끝을 결정하는지 확인한다. HTTP/1.x에서 Transfer-encoding 헤더 필드가 있는 경우에 RFC 2616에 따라서 Content-Length 헤더는 무시해야 한다. HTTP/2 또는 HTTP/3를 사용할 때 Content-Length 헤더 필드가 있는 경우에 수신기는 DATA 프레임의 길이와 일치하는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V4.2.2",
              "Ordinal": 2,
              "Description": "HTTP 메세지를 생성할 때, 요청 smuggling 공격을 예방하기 위해서 HTTP 프로토콜의 프레이밍 방식에 의해 결정된 Content의 길이와 Content-Length 헤더 필드가 충돌하지 않는지 확인한다. ",
              "L": "3"
            },
            {
              "Shortcode": "V4.2.3",
              "Ordinal": 3,
              "Description": "응답 분할 및 헤더 인젝션 공격을 예방하기 위해서 애플리케이션이 Transfer-encoding과 같은 connection-specific 헤더 필드를 가진 HTTP/2또는 HTTP/3 메세지를 전송하거나 수락하지 않는지 확인한다.",
              "L": "3"
            },
            {
              "Shortcode": "V4.2.4",
              "Ordinal": 4,
              "Description": "헤더 인젝션 공격을 예방하기 위해서, 애플리케이션이 헤더 이름과 값에 CR(\\r), LF(\\n), CRLF(\\r\\n)과 같은 줄바꿈 문자가 포함되어 있지 않은 HTTP/2 및 HTTP/3 요청만 허용하는지 확인한다.",
              "L": "3"
            },
            {
              "Shortcode": "V4.2.5",
              "Ordinal": 5,
              "Description": "애플리케이션(백엔드 또는 프론트엔드)이 요청을 빌드하고 전송하는 경우, 수신 구성 요소가 수학하기에는 너무 긴 URI(ex. API 호출) 또는 HTTP 요청 헤더 필드(ex. Authorization 또는 Cookie)를 생성하지 않도록 검증, 검열 또는 기타 메커니즘을 사용하는지 확인한다. 이로 인해서 지나치게 긴 요청(ex. 긴 쿠키 헤더 필드)을 보낼 때와 같이 서비스 거부가 발생하여 서버가 항상 오류 상태로 응답할 수 있다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V4.3",
          "Ordinal": 3,
          "Name": "GraphQL",
          "Items": [
            {
              "Shortcode": "V4.3.1",
              "Ordinal": 1,
              "Description": "쿼리 허용 목록, 깊이 제한, 양 제한 또는 쿼리 비용 분석을 사용하여 값비싼 중첩 쿼리로 인해 GraphQL 또는 데이터 계층 표현식 거부(DOS)를 방지하는지 확인한다.",
              "L": "2"
            },
            {
              "Shortcode": "V4.3.2",
              "Ordinal": 2,
              "Description": "GraphQL API가 다른 사용자에 의해 사용되지 않는 한, 운영 환경에서 GraphQL 점검 쿼리들이 비비활성화되어 있는지 확인한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V4.4",
          "Ordinal": 4,
          "Name": "WebSocket",
          "Items": [
            {
              "Shortcode": "V4.4.1",
              "Ordinal": 1,
              "Description": "모든 WebSocket 연결에 WebSocket over TLS(WSS)이 사용되는지 확인한다.",
              "L": "1"
            },
            {
              "Shortcode": "V4.4.2",
              "Ordinal": 2,
              "Description": "초기 HTTP WebSocket Handshake 중에 기존 헤더 필드가 애플리케이션에 허용된 기존 목록과 대조되는지 확인한다.",
              "L": "2"
            },
            {
              "Shortcode": "V4.4.3",
              "Ordinal": 3,
              "Description": "애플리케이션의 표준 세션 관리를 사용할 수 없는 경우, 관련 세션 관리 보안 요구 사항을 준수하는 전용 토큰이 사용되고 있는지 확인한다.",
              "L": "2"
            },
            {
              "Shortcode": "V4.4.4",
              "Ordinal": 4,
              "Description": "기존 HTTPS 세션을 WebSocket 채널로 전환할 때 이전에 인증된 HTTPS 세션을 통해 전용 WebSocket 세션 관리 토큰을 처음 얻거나 검증하는지 확인한다.",
              "L": "2"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V5",
      "Ordinal": 5,
      "ShortName": "File",
      "Name": "파일 처리",
      "Items": [
        {
          "Shortcode": "V5.1",
          "Ordinal": 1,
          "Name": "파일 처리 문서화",
          "Items": [
            {
              "Shortcode": "V5.1.1",
              "Ordinal": 1,
              "Description": "업로드 기능별로 허용되는 파일 형식, 예상되는 파일 확장자, 그리고 최대 크기(압축 해제된 크기 포함)가 문서에 정의되어 있는지 검증해야 한다. 또한, 악성 파일이 탐지될 때 애플리케이션이 어떻게 동작하는지와 같이, 최종 사용자가 파일을 안전하게 다운로드하고 처리할 수 있도록 하는 방법이 문서에 명시되어 있는지 확인해야 한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V5.2",
          "Ordinal": 2,
          "Name": "파일 업로드 및 콘텐츠",
          "Items": [
            {
              "Shortcode": "V5.2.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 성능 저하나 서비스 거부 공격(Denial of Service; DoS)을 유발하지 않고 처리할 수 있는 크기의 파일만 허용하는지 검증해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V5.2.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 파일 자체 또는 zip 파일과 같은 아카이브 내에서 파일을 허용할 때, 파일 확장자가 예상 파일 확장자와 일치하는지 확인하고 내용이 확장자로 표현된 유형과 일치하는지 확인하는지 검증해야 한다. 여기에는 초기 '매직 바이트(magic bytes)' 확인, 이미지 재작성 수행, 파일 내용 유효성 검사를 위한 전문 라이브러리 사용이 포함되지만 이에 국한되지 않는다. L1의 경우, 특정 비즈니스 또는 보안 결정을 내리는 데 사용되는 파일에만 집중할 수 있다. L2 이상에서는 허용되는 모든 파일에 적용되어야 한다",
              "L": "1"
            },
            {
              "Shortcode": "V5.2.3",
              "Ordinal": 3,
              "Description": "애플리케이션이 압축 파일(예: zip, gz, docx, odt)을 압축 해제하기 전에 허용되는 최대 압축 해제 크기와 최대 파일 수를 확인하는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V5.2.4",
              "Ordinal": 4,
              "Description": "단일 사용자가 너무 많은 파일이나 과도하게 큰 파일로 저장 공간을 채우지 않도록 사용자별 파일 크기 할당량(quota) 및 최대 파일 수가 적용되는지 검증해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V5.2.5",
              "Ordinal": 5,
              "Description": "애플리케이션이 심볼릭 링크(symlink)를 포함하는 압축 파일 업로드를 허용하지 않는지 검증해야 한다. 단, 이러한 기능이 특별히 요구되는 경우에는 심볼릭 링크할 수 있는 파일의 허용 목록(allowlist)을 강제하는 것이 필요하다.",
              "L": "3"
            },
            {
              "Shortcode": "V5.2.6",
              "Ordinal": 6,
              "Description": "픽셀 플러드 공격(Pixel Flood Attack)을 방지하기 위해, 애플리케이션이 업로드된 이미지의 픽셀 크기가 허용된 최대값보다 큰 경우 해당 이미지를 거부하는지 검증해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V5.3",
          "Ordinal": 3,
          "Name": "파일 저장",
          "Items": [
            {
              "Shortcode": "V5.3.1",
              "Ordinal": 1,
              "Description": "신뢰할 수 없는 입력으로 업로드되거나 생성되어 공개 폴더에 저장된 파일이 HTTP 요청으로 직접 접근될 때 서버 측 프로그램 코드로 실행되지 않는지 검증해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V5.3.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 파일 작업을 위한 파일 경로를 생성할 때, 사용자 제출 파일명 대신 내부적으로 생성되거나 신뢰할 수 있는 데이터를 사용하는지 검증해야 한다. 만약 사용자 제출 파일명 또는 파일 메타데이터를 반드시 사용해야 한다면, 경로 탐색(path traversal), 로컬 또는 원격 파일 포함(Local File Inclusion; LFI, Remote File Inclusion; RFI), 그리고 서버 측 요청 위조(Server-side Request Forgery; SSRF) 공격으로부터 보호하기 위해 엄격한 유효성 검사 및 정제(Sanitization)가 적용되는지 확인해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V5.3.3",
              "Ordinal": 3,
              "Description": "파일 압축 해제와 같은 서버 측 파일 처리가 zip slip과 같은 취약점을 방지하기 위해 사용자 제공 경로 정보를 무시하는지 검증해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V5.4",
          "Ordinal": 4,
          "Name": "파일 다운로드",
          "Items": [
            {
              "Shortcode": "V5.4.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 JSON, JSONP 또는 URL 파라미터를 포함한 사용자 제출 파일명을 검증하거나 무시하는지 검증해야 하고, 응답의 Content-Disposition 헤더 필드에 파일명을 명시하는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V5.4.2",
              "Ordinal": 2,
              "Description": "제공되는 파일 이름(예: HTTP 응답 헤더 필드 또는 이메일 첨부 파일)이 문서 구조를 보존하고 삽입 공격(Injection Attack)을 방지하기 위해 인코딩되거나 정제되는지 검증해야 한다. (예: RFC 6266 준수)",
              "L": "2"
            },
            {
              "Shortcode": "V5.4.3",
              "Ordinal": 3,
              "Description": "신뢰할 수 없는 소스에서 얻은 파일이 알려진 악성 콘텐츠 제공을 방지하기 위해 안티바이러스 스캐너에 의해 검사되는지 검증해야 한다.",
              "L": "2"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V6",
      "Ordinal": 6,
      "ShortName": "Authentication",
      "Name": "인증",
      "Items": [
        {
          "Shortcode": "V6.1",
          "Ordinal": 1,
          "Name": "Authentication Documentation",
          "Items": [
            {
              "Shortcode": "V6.1.1",
              "Ordinal": 1,
              "Description": "인증 문서가 크리덴셜 스터핑, 비밀번호 무차별 대입 공격 등을 방어하기 위해 속도 제한, 자동화 방지, 적응형 응답(adaptive response)과 같은 제어가 어떻게 사용되는지를 정의한다. 또한, 이러한 제어가 어떻게 구성되는지와 악의적으로 계정을 잠그는 것을 방지하는 방법을 명확히 하는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.1.2",
              "Ordinal": 2,
              "Description": "조직명, 제품명, 시스템 식별자, 프로젝트 코드명, 부서명 또는 역할명 등 문맥적으로 특정된 단어의 변형을 포함하여, 비밀번호에 사용되지 않도록 문서화된 단어 목록이 있는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.1.3",
              "Ordinal": 3,
              "Description": "애플리케이션이 여러 인증 경로를 포함하는 경우, 이들 모두가 문서화되어 있으며 각 경로에 대해 일관되게 적용되는 보안 제어와 인증 강도가 정의되어 있는지 검증한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V6.2",
          "Ordinal": 2,
          "Name": "비밀번호 보안",
          "Items": [
            {
              "Shortcode": "V6.2.1",
              "Ordinal": 1,
              "Description": "사용자가 설정하는 비밀번호가 최소 8자 이상이어야 하며, 최소 15자 이상을 강력히 권장하는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.2.2",
              "Ordinal": 2,
              "Description": "사용자가 비밀번호를 변경할 수 있는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.2.3",
              "Ordinal": 3,
              "Description": "비밀번호 변경 기능이 사용자의 현재 비밀번호와 새 비밀번호를 요구하는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.2.4",
              "Ordinal": 4,
              "Description": "계정 등록 또는 비밀번호 변경 시 제출된 비밀번호가 최소 3000개의 상위 비밀번호 목록과 비교 및 검사되는지, 이때 애플리케이션 비밀번호 정책(예: 최소 길이)을 만족하는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.2.5",
              "Ordinal": 5,
              "Description": "비밀번호는 어떤 구성도 허용되며, 허용되는 문자 유형에 대한 제한이 없는지 검증한다. 대/소문자, 숫자, 특수문자에 대한 최소 개수 요구사항이 없어야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.2.6",
              "Ordinal": 6,
              "Description": "비밀번호 입력 필드가 type=password를 사용하여 입력을 마스킹하는지 검증한다. 애플리케이션은 사용자가 전체 비밀번호나 마지막 입력 문자를 일시적으로 볼 수 있도록 허용할 수 있다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.2.7",
              "Ordinal": 7,
              "Description": "붙여넣기 기능, 브라우저 비밀번호 도우미, 외부 비밀번호 관리자의 사용이 허용되는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.2.8",
              "Ordinal": 8,
              "Description": "애플리케이션이 비밀번호를 사용자로부터 수신한 그대로 검증하며, 대소문자 변경이나 잘림(truncation)과 같은 수정 없이 처리하는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.2.9",
              "Ordinal": 9,
              "Description": "비밀번호가 최소 64자까지 허용되는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.2.10",
              "Ordinal": 10,
              "Description": "사용자의 비밀번호는 손상되었음이 발견되거나 사용자가 교체할 때까지 유효하며, 애플리케이션이 주기적인 자격 증명 교체를 요구하지 않는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.2.11",
              "Ordinal": 11,
              "Description": "문서화된 문맥별 단어 목록을 사용하여 추측하기 쉬운 비밀번호가 생성되지 않도록 하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.2.12",
              "Ordinal": 12,
              "Description": "계정 등록 또는 비밀번호 변경 시 제출된 비밀번호가 유출된 비밀번호 집합과 비교 및 검사되는지 검증한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V6.3",
          "Ordinal": 3,
          "Name": "일반 인증 보안",
          "Items": [
            {
              "Shortcode": "V6.3.1",
              "Ordinal": 1,
              "Description": "애플리케이션의 보안 문서에 따라 크리덴셜 스터핑 및 비밀번호 무차별 대입 공격을 방지하기 위한 제어가 구현되어 있는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.3.2",
              "Ordinal": 2,
              "Description": "“root”, “admin”, “sa”와 같은 기본 사용자 계정이 애플리케이션에 존재하지 않거나 비활성화되어 있는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.3.3",
              "Ordinal": 3,
              "Description": "애플리케이션 접근 시 반드시 MFA 또는 단일 요소 인증 메커니즘의 조합을 사용하는지 검증한다. L3의 경우, 인증을 수행하려는 사용자의 의도를 검증하기 위해 사용자가 직접 수행하는 동작(예: FIDO 하드웨어 키 또는 모바일 기기에서 버튼을 누르는 행위)을 요구함으로써, 피싱 공격에 대한 침해 및 위장 저항성을 제공하는 하드웨어 기반 인증 메커니즘이 반드시 하나의 요소로 포함되어야 한다. 이 요구사항에서 고려 사항을 완화하려는 경우, 완전히 문서화된 근거와 포괄적인 보완 통제가 반드시 수반되어야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.3.4",
              "Ordinal": 4,
              "Description": "여러 인증 경로가 존재하는 경우, 문서화되지 않은 경로가 없어야 하며 보안 제어와 인증 강도가 일관되게 적용되는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.3.5",
              "Ordinal": 5,
              "Description": "사용자가 의심스러운 인증 시도에 대해 성공 여부와 관계 없이 알림을 제공받는지 검증한다. 여기에는 비정상적인 위치나 클라이언트에서의 인증 시도, 부분적으로만 성공한 인증(여러 요소 중 하나만 성공한 경우), 장기간 비활성 상태 이후의 인증 시도, 또는 여러 번의 인증 실패 후 성공한 인증이 포함될 수 있다.",
              "L": "3"
            },
            {
              "Shortcode": "V6.3.6",
              "Ordinal": 6,
              "Description": "이메일이 단일 또는 다중 요소 인증 메커니즘으로 사용되지 않는지 검증한다.",
              "L": "3"
            },
            {
              "Shortcode": "V6.3.7",
              "Ordinal": 7,
              "Description": "자격 증명 재설정, 사용자명/이메일 수정 등 인증 관련 정보 변경 이후 사용자에게 통지되는지 검증한다.",
              "L": "3"
            },
            {
              "Shortcode": "V6.3.8",
              "Ordinal": 8,
              "Description": "오류 메시지, HTTP 응답 코드, 응답 시간 차이 등을 통해 유효한 사용자를 유추할 수 없으며, 비밀번호 등록/찾기 기능에도 동일한 보호가 적용되는지 검증한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V6.4",
          "Ordinal": 4,
          "Name": "인증 요소 수명 주기 및 복구",
          "Items": [
            {
              "Shortcode": "V6.4.1",
              "Ordinal": 1,
              "Description": "시스템이 생성하는 초기 비밀번호나 활성화 코드가 안전하게 난수로 생성되며, 기존 비밀번호 정책을 따르고, 짧은 기간 내 또는 최초 사용 시 만료되는지 검증한다. 초기 비밀번호는 장기 비밀번호로 허용되지 않아야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.4.2",
              "Ordinal": 2,
              "Description": "비밀번호 힌트나 지식 기반 인증(“비밀 질문”)이 존재하지 않는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V6.4.3",
              "Ordinal": 3,
              "Description": "분실된 비밀번호에 대한 재설정 절차가 안전하게 구현되며, MFA를 우회하지 않는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.4.4",
              "Ordinal": 4,
              "Description": "MFA 요소 분실 시, 등록 시와 동일 수준의 신원 증명이 수행되는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.4.5",
              "Ordinal": 5,
              "Description": "만료 예정인 인증 메커니즘에 대한 갱신 안내가 충분한 시간 전에 발송되며, 필요한 경우 자동 알림이 구성되는지 검증한다",
              "L": "3"
            },
            {
              "Shortcode": "V6.4.6",
              "Ordinal": 6,
              "Description": "관리자가 사용자 비밀번호 재설정 절차를 시작할 수 있으나, 사용자의 비밀번호를 직접 변경하거나 지정할 수 없는지 검증한다. 이는 관리자가 사용자의 비밀번호를 알지 못하도록 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V6.5",
          "Ordinal": 5,
          "Name": "General Multi-factor authentication requirements",
          "Items": [
            {
              "Shortcode": "V6.5.1",
              "Ordinal": 1,
              "Description": "조회 secret, 대역 외 인증 요청 및 코드, 시간 기반 일회용 비밀번호가 단 한 번만 성공적으로 사용 가능한지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.5.2",
              "Ordinal": 2,
              "Description": "애플리케이션 백엔드에 저장될 때, 엔트로피가 112비트 미만인 룩업 시크릿(예: 무작위 영숫자 19자 또는 무작위 숫자 34자)은 32비트 무작위 솔트(salt)를 포함하는 사전 승인된 비밀번호 저장용 해시 알고리즘으로 해시되는지 검증한다. 룩업 시크릿이 112비트 이상의 엔트로피를 가진 경우에는 표준 해시 함수를 사용할 수 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.5.3",
              "Ordinal": 3,
              "Description": "룩업 시크릿, 대역 외 인증 코드, 그리고 시간 기반 일회용 비밀번호의 시드가 예측 가능한 값을 피하기 위해 암호학적으로 안전한 의사난수 생성기(CSPRNG)를 사용하여 생성되는지 검증한다. ",
              "L": "2"
            },
            {
              "Shortcode": "V6.5.4",
              "Ordinal": 4,
              "Description": "룩업 시크릿과 대역 외 인증 코드가 최소 20비트의 엔트로피를 가지는지 검증한다. 일반적으로 무작위 영숫자 4자 또는 무작위 숫자 6자가 충분하다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.5.5",
              "Ordinal": 5,
              "Description": "대역 외 인증 요청, 코드 또는 토큰과 시간 기반 일회용 비밀번호가 정의된 수명을 가지는지 검증한다. 대역 외 요청의 최대 수명은 10분이어야 하며, TOTP의 최대 수명은 30초이어야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.5.6",
              "Ordinal": 6,
              "Description": "도난이나 기타 손실의 경우 모든 인증 요소(물리적 장치 포함)를 해지할 수 있는지 검증한다.",
              "L": "3"
            },
            {
              "Shortcode": "V6.5.7",
              "Ordinal": 7,
              "Description": "생체 인식 인증 메커니즘은 반드시 보조 요소로만 사용되어야 하며, “소유하고 있는 것” 또는 “알고 있는 것” 중 하나와 함께 사용되는지 검증한다.",
              "L": "3"
            },
            {
              "Shortcode": "V6.5.8",
              "Ordinal": 8,
              "Description": "시간 기반 일회용 비밀번호는 신뢰할 수 있는 서비스의 시간 소스를 기준으로 검증되어야 하며, 신뢰할 수 없거나 클라이언트에서 제공한 시간을 기반으로 해서는 안 된다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V6.6",
          "Ordinal": 6,
          "Name": "대역 외(Out-of-Band) 인증 메커니즘",
          "Items": [
            {
              "Shortcode": "V6.6.1",
              "Ordinal": 1,
              "Description": "공중 교환 전화망(PSTN)을 사용하여 전화나 SMS를 통해 일회용 비밀번호(OTPs)를 전달하는 인증 메커니즘은, 해당 전화번호가 사전에 검증되었을 때만 제공되어야 하며, 더 강력한 대체 방법(예: 시간 기반 일회용 비밀번호)도 제공되어야 하고, 서비스는 사용자에게 이러한 보안 위험에 대한 정보를 제공해야 한다. L3 애플리케이션의 경우, 전화와 SMS는 옵션으로 제공되어서는 안 된다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.6.2",
              "Ordinal": 2,
              "Description": "대역 외 인증 요청, 코드 또는 토큰은 생성된 원래 인증 요청에만 바인딩되어야 하며, 이전이나 이후의 요청에는 사용할 수 없어야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.6.3",
              "Ordinal": 3,
              "Description": "코드 기반 대역 외 인증 메커니즘이 속도 제한 등을 통해 무차별 대입 공격으로부터 보호되는지 검증한다. 또한 최소 64비트 이상의 엔트로피를 가진 코드를 사용하는 것도 고려해야한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.6.4",
              "Ordinal": 4,
              "Description": "다중요소 인증에 푸시 알림이 사용되는 경우, 푸시 폭탄(push bombing) 공격을 방지하기 위해 속도 제한을 적용해야 한다. 또한 숫자 일치 기법 역시 이 위험을 완화할 수 있다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V6.7",
          "Ordinal": 7,
          "Name": "암호학적 인증 메커니즘",
          "Items": [
            {
              "Shortcode": "V6.7.1",
              "Ordinal": 1,
              "Description": "암호학적 인증 단언(assertion)을 검증하는 데 사용되는 인증서는 수정으로부터 보호되는 방식으로 저장되는지 검증한다.",
              "L": "3"
            },
            {
              "Shortcode": "V6.7.2",
              "Ordinal": 2,
              "Description": "챌린지 논스(nonce)는 최소 64비트 길이여야 하며, 통계적으로 고유하거나 해당 암호 장치의 수명 동안 고유해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V6.8",
          "Ordinal": 8,
          "Name": "ID 제공자(IdP)를 통한 인증",
          "Items": [
            {
              "Shortcode": "V6.8.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 다중 ID 제공자(IdP)를 지원하는 경우, 사용자의 신원이 다른 지원 IdP를 통해 위조될 수 없는지 검증한다. (예: 동일한 사용자 식별자를 사용하는 방식). 표준적인 대응책은 애플리케이션이 IdP ID(네임스페이스 역할)와 IdP 내 사용자 ID의 조합을 사용하여 사용자를 등록하고 식별하는 것이다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.8.2",
              "Ordinal": 2,
              "Description": "인증 단언(예: JWT 또는 SAML 단언)의 디지털 서명이 존재하고 무결성이 항상 유지되는지를 검증한다. 서명이 없거나 유효하지 않은 단언은 거부해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.8.3",
              "Ordinal": 3,
              "Description": "SAML 단언이 재생 공격의 방지를 위해 고유하게 처리되는지, 유효 기간 내에 단 한 번만 사용되는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V6.8.4",
              "Ordinal": 4,
              "Description": "애플리케이션이 별도의 ID 제공자(IdP)를 사용하고 특정 기능에 대해 특정 인증 강도, 방식, 또는 최근성을 요구하는 경우, 애플리케이션은 IdP가 반환한 정보를 사용하여 이를 검증해야 한다. 예를 들어, OIDC가 사용되는 경우, 이는 ‘acr’, ‘amr’, ‘auth_time’(존재하는 경우)과 같은 ID 토큰 클레임을 검증함으로써 달성할 수 있다. IdP가 이 정보를 제공하지 않는 경우, 애플리케이션은 최소 강도의 인증 메커니즘(예: 사용자 이름과 비밀번호를 사용하는 단일요소 인증)이 사용되었다고 가정하는 문서화된 대체 접근법을 가져야 한다.",
              "L": "2"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V7",
      "Ordinal": 7,
      "ShortName": "Session",
      "Name": "세션 관리",
      "Items": [
        {
          "Shortcode": "V7.1",
          "Ordinal": 1,
          "Name": "세션 관리 문서화",
          "Items": [
            {
              "Shortcode": "V7.1.1",
              "Ordinal": 1,
              "Description": "사용자의 세션 비활성 시간 초과 및 절대 최대 세션 수명에 대한 문서가 존재하고, 다른 제어와의 조합에서 적절하며, NIST SP 800-63B 재인증 요구사항에서 벗어날 시 그 근거가 문서에 포함되어 있는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V7.1.2",
              "Ordinal": 2,
              "Description": "문서가 하나의 계정에서 허용되는 동시(병렬) 세션 수와 활성 세션 수의 최대값에 도달했을 때의 의도된 동작과 수행할 조치를 정의하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V7.1.3",
              "Ordinal": 3,
              "Description": "통합 신원 관리 생태계(예: SSO 시스템)의 일부로 사용자 세션을 생성하고 관리하는 모든 시스템이 문서화되어 있으며, 세션 수명, 종료, 재인증이 필요한 기타 조건을 조율하기 위한 제어가 포함되어 있는지 검증한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V7.2",
          "Ordinal": 2,
          "Name": "기본 세션 관리 보안",
          "Items": [
            {
              "Shortcode": "V7.2.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 모든 세션 토큰 검증을 신뢰할 수 있는 백엔드 서비스에서 수행하는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V7.2.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 세션 관리를 위해 정적 API 시크릿이나 키가 아닌, 자체 포함 토큰 또는 참조 토큰을 동적으로 생성하여 사용하는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V7.2.3",
              "Ordinal": 3,
              "Description": "참조 토큰이 사용자 세션을 나타내는 데 사용되는 경우, 그 토큰이 고유하고, 암호학적으로 안전한 의사난수 생성기(CSPRNG)를 사용해 생성되며 최소 128비트의 엔트로피를 갖는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V7.2.4",
              "Ordinal": 4,
              "Description": "애플리케이션이 사용자 인증(재인증 포함) 시 새로운 세션 토큰을 생성하고 기존 세션 토큰을 종료하는지 검증한다.",
              "L": "1"
            }
          ]
        },
        {
          "Shortcode": "V7.3",
          "Ordinal": 3,
          "Name": "세션 타임아웃",
          "Items": [
            {
              "Shortcode": "V7.3.1",
              "Ordinal": 1,
              "Description": "위험 분석 및 문서화된 보안 결정에 따라 재인증을 강제하는 비활성 시간 초과가 존재하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V7.3.2",
              "Ordinal": 2,
              "Description": "위험 분석 및 문서화된 보안 결정에 따라 재인증을 강제하는 절대 최대 세션 수명이 존재하는지 검증한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V7.4",
          "Ordinal": 4,
          "Name": "세션 종료",
          "Items": [
            {
              "Shortcode": "V7.4.1",
              "Ordinal": 1,
              "Description": "로그아웃이나 만료와 같이 세션 종료가 트리거될 때, 애플리케이션이 해당 세션의 추가 사용을 허용하지 않는지 검증한다. 참조 토큰 또는 상태 유지형 세션의 경우, 이는 애플리케이션 백엔드에서 세션 데이터를 무효화하는 것을 의미한다. 자체 포함 토큰을 사용하는 애플리케이션은 종료된 토큰 목록 유지, 사용자별 날짜·시간 이전에 발급된 토큰 거부, 사용자별 서명 키 회전과 같은 방법을 사용해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V7.4.2",
              "Ordinal": 2,
              "Description": "사용자 계정이 비활성화되거나 삭제될 때(예: 직원 퇴사), 애플리케이션이 모든 활성 세션을 종료하는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V7.4.3",
              "Ordinal": 3,
              "Description": "비밀번호 재설정·복구를 통한 변경, MFA 설정 변경 등 어떤 인증 요소라도 성공적으로 변경 또는 제거한 후, 모든 다른 활성 세션을 종료할 수 있는 옵션을 제공하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V7.4.4",
              "Ordinal": 4,
              "Description": "인증이 필요한 모든 페이지의 로그아웃 기능에 접근하는 것이 쉽고 잘 보이는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V7.4.5",
              "Ordinal": 5,
              "Description": "애플리케이션 관리자가 개별 사용자 또는 모든 사용자의 활성 세션을 종료할 수 있는지 검증한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V7.5",
          "Ordinal": 5,
          "Name": "세션 악용 방어",
          "Items": [
            {
              "Shortcode": "V7.5.1",
              "Ordinal": 1,
              "Description": "이메일 주소, 전화번호, MFA 구성, 계정 복구에 사용되는 기타 정보 등 인증에 영향을 줄 수 있는 민감한 계정 속성을 변경하기 전에 전체 재인증을 요구하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V7.5.2",
              "Ordinal": 2,
              "Description": "사용자가 현재 활성 세션을 전체 또는 일부 확인하고(최소 요소 한 개에 대한 인증을 다시 수행한 후) 종료할 수 있는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V7.5.3",
              "Ordinal": 3,
              "Description": "매우 민감한 거래나 작업을 수행하기 전에 최소 한 요소 인증 또는 2차 검증을 요구하는지 검증한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V7.6",
          "Ordinal": 6,
          "Name": "페더레이션 재인증",
          "Items": [
            {
              "Shortcode": "V7.6.1",
              "Ordinal": 1,
              "Description": "RP와 IdP 간 세션 수명과 종료가 문서대로 동작하며, IdP 인증 이벤트 간의 최대 시간이 도달하는 경우 등 필요한 시점에 재인증을 요구하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V7.6.2",
              "Ordinal": 2,
              "Description": "세션 생성 시 사용자 동의 또는 명시적 동작을 요구하여, 사용자 상호작용 없이 새로운 애플리케이션 세션이 생성되지 않도록 하는지 검증한다.",
              "L": "2"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V8",
      "Ordinal": 8,
      "ShortName": "Authorization",
      "Name": "권한 부여",
      "Items": [
        {
          "Shortcode": "V8.1",
          "Ordinal": 1,
          "Name": "권한 부여 문서화",
          "Items": [
            {
              "Shortcode": "V8.1.1",
              "Ordinal": 1,
              "Description": "권한 부여 문서가 소비자 권한과 자원 속성에 따라 기능 수준 및 데이터별 접근을 제한하는 규칙을 정의하는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V8.1.2",
              "Ordinal": 2,
              "Description": "권한 부여 문서가 소비자 권한과 자원 속성에 따라 필드 수준 접근 제한(읽기 및 쓰기 모두)을 정의하는지 검증한다. 이러한 규칙은 관련 데이터 객체의 상태(state)나 상태값(status)과 같은 다른 속성 값에 의존할 수 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V8.1.3",
              "Ordinal": 3,
              "Description": "애플리케이션 문서가 인증 및 권한 부여와 관련된 보안 결정을 내리는 데 사용되는 환경적, 맥락적 속성(예: 시간대, 사용자 위치, IP 주소, 디바이스 등)을 정의하는지 검증한다.",
              "L": "3"
            },
            {
              "Shortcode": "V8.1.4",
              "Ordinal": 4,
              "Description": "인증 및 권한 부여 문서가 기능 수준, 데이터별, 필드 수준 권한 부여에 더해 환경적, 맥락적 요소가 의사 결정에 어떻게 사용되는지 정의하는지 검증한다. 여기에는 평가되는 속성, 위험 임계값, 수행되는 조치(예: 허용, 추가 인증 요청, 거부, 단계적 인증)을 포함하는 것을 권장한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V8.2",
          "Ordinal": 2,
          "Name": "일반 권한 부여 설계",
          "Items": [
            {
              "Shortcode": "V8.2.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 기능 수준의 접근을 명시적 권한이 있는 소비자에게만 허용하는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V8.2.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 특정 데이터 항목에 대한 명시적 권한이 있는 소비자에게만 데이터별 접근을 허용하여, 안전하지 않은 직접 객체 참조(IDOR) 및 객체 수준 권한 부여 취약점(BOLA)을 방지하는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V8.2.3",
              "Ordinal": 3,
              "Description": "애플리케이션이 특정 필드에 대한 명시적 권한이 있는 소비자에게만 필드 수준 접근을 허용하여, 객체 속성 수준 권한 부여 취약점(BOPLA)을 방지하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V8.2.4",
              "Ordinal": 4,
              "Description": "애플리케이션 문서에서 정의한 바에 따라, 소비자의 환경적, 맥락적 속성(예: 시간대, 위치, IP 주소 또는 장치)에 기반한 적응형 보안 제어가 인증 및 권한 부여 결정에 구현되는지 검증한다. 이러한 제어는 소비자가 새 세션을 시작할 때뿐만 아니라 기존 세션 중에도 반드시 적용되어야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V8.3",
          "Ordinal": 3,
          "Name": "운영 수준 권한 부여",
          "Items": [
            {
              "Shortcode": "V8.3.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 권한 부여 규칙을 신뢰할 수 있는 서비스 계층에서 적용하고, 클라이언트 측 JavaScript처럼 신뢰할 수 없는 소비자가 조작할 수 있는 제어에 의존하지 않는지 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V8.3.2",
              "Ordinal": 2,
              "Description": "권한 부여 결정에 영향을 미치는 값의 변경 사항이 즉시 적용되는지 검증한다. 자체 포함 토큰(self-contained token)과 같이 즉시 적용이 불가능한 경우, 소비자가 더 이상 권한이 없는 작업을 수행할 때 이를 알리고 변경을 되돌리는 완화 제어를 반드시 두어야 한다. 단, 이 방법은 정보 유출을 방지하지는 못한다.",
              "L": "3"
            },
            {
              "Shortcode": "V8.3.3",
              "Ordinal": 3,
              "Description": "객체에 대한 접근이, 대리인이나 이를 대신 수행하는 서비스의 권한이 아닌, 원래 주체(예: 소비자)의 권한에 기반하는지 검증한다. 예를 들어, 소비자가 인증을 위해 자체 포함 토큰을 사용하여 웹 서비스를 호출하고, 해당 서비스가 다른 서비스에 데이터를 요청하는 경우, 두 번째 서비스는 첫 번째 서비스의 머신-투-머신 토큰이 아니라 소비자의 토큰을 사용하여 권한 결정을 내려야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V8.4",
          "Ordinal": 4,
          "Name": "기타 권한 부여 고려사항",
          "Items": [
            {
              "Shortcode": "V8.4.1",
              "Ordinal": 1,
              "Description": "다중 테넌트 애플리케이션이 교차 테넌트 제어를 사용하여, 소비자의 작업이 권한이 없는 다른 테넌트에 영향을 미치지 않도록 하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V8.4.2",
              "Ordinal": 2,
              "Description": "관리 인터페이스 접근이 연속적인 소비자 신원 검증, 장치 보안 상태 평가, 맥락 기반 위험 분석 등 복수의 보안 계층을 포함하는지 검증한다. 네트워크 위치나 신뢰된 엔드포인트가 무단 접근 가능성을 줄일 수는 있더라도, 단독으로 권한 부여 판단의 유일한 요소가 되어서는 안 된다.",
              "L": "3"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V9",
      "Ordinal": 9,
      "ShortName": "Self",
      "Name": "자체 포함 토큰(self-contained token)",
      "Items": [
        {
          "Shortcode": "V9.1",
          "Ordinal": 1,
          "Name": "토큰 출처 및 무결성",
          "Items": [
            {
              "Shortcode": "V9.1.1",
              "Ordinal": 1,
              "Description": "자체 포함 토큰 내용을 허용하기 전에 변조를 방지하기 위해 디지털 서명 또는 메시지 인증 코드(MAC)를 사용하여 토큰의 무결성을 검증해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V9.1.2",
              "Ordinal": 2,
              "Description": "주어진 컨텍스트에 대해 자체 포함 토큰을 생성하고 검증할 때, 허용 목록에 있는 알고리즘만 사용될 수 있는지 검증해야 한다. 허용 목록에는 사용 가능한 알고리즘을 모두 포함해야 하며, 이상적으로는 대칭 또는 비대칭 알고리즘 중 하나만을 포함해야 한다. 또한 'None' 알고리즘은 반드시 제외해야 한다. 대칭 및 비대칭 알고리즘 모두를 지원해야 하는 경우, 키 혼동을 방지하기 위해 추가 제어가 필요하다.",
              "L": "1"
            },
            {
              "Shortcode": "V9.1.3",
              "Ordinal": 3,
              "Description": "자체 포함 토큰을 검증하는 데 사용되는 키 자료가 토큰 발행자를 위한 신뢰할 수 있는 사전 구성된 출처에서 비롯되었는지 검증하여, 공격자가 신뢰할 수 없는 출처 및 키를 지정하는 것을 방지해야 한다. JWT 및 기타 JWS 구조의 경우, 'jku', 'x5u', 'jwk'와 같은 헤더는 신뢰할 수 있는 출처의 허용 목록에 대해 검증되어야 한다.",
              "L": "1"
            }
          ]
        },
        {
          "Shortcode": "V9.2",
          "Ordinal": 2,
          "Name": "토큰 내용",
          "Items": [
            {
              "Shortcode": "V9.2.1",
              "Ordinal": 1,
              "Description": "토큰 데이터에 유효 기간이 존재하는 경우, 검증 시간이 이 유효 기간 내에 있을 때만 토큰 및 해당 내용이 허용되는지 검증해야 한다. 예를 들어, JWT의 경우 'nbf' 및 'exp' 클레임이 검증되어야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V9.2.2",
              "Ordinal": 2,
              "Description": "토큰을 수신하는 서비스가 토큰 내용을 수락하기 전에 올바른 유형이며 의도된 목적을 위한 것인지 토큰을 검증하는지 확인해야 한다. 예를 들어, 인가 결정에는 액세스 토큰만 허용될 수 있으며, 사용자 인증을 증명하는 데는 ID 토큰만 사용될 수 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V9.2.3",
              "Ordinal": 3,
              "Description": "서비스가 대상 서비스(audience)와 함께 사용하기 위한 토큰만 허용하는지 검증해야 한다. JWT의 경우, 서비스에 정의된 허용 목록에 대해 'aud' 클레임을 검증함으로써 이를 달성할 수 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V9.2.4",
              "Ordinal": 4,
              "Description": "토큰 발행자가 다른 대상(audience)에게 토큰을 발행하기 위해 동일한 개인 키를 사용하는 경우, 발행된 토큰이 의도된 대상을 고유하게 식별하는 대상 제한을 포함하는지 검증해야 한다. 이는 토큰이 의도하지 않은 대상에서 재사용되는 것을 방지한다. 대상 식별자가 동적으로 프로비저닝되는 경우, 토큰 발행자는 대상 위장(audience impersonation)을 초래하지 않도록 대상들을 검증해야 한다.",
              "L": "2"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V10",
      "Ordinal": 10,
      "ShortName": "OAuth",
      "Name": "OAuth와 OIDC",
      "Items": [
        {
          "Shortcode": "V10.1",
          "Ordinal": 1,
          "Name": "일반적인 OAuth 및 OIDC 보안",
          "Items": [
            {
              "Shortcode": "V10.1.1",
              "Ordinal": 1,
              "Description": "엄격하게 필요한 구성 요소에만 토큰이 전송되는지 검증해야 한다. 예를 들어, 브라우저 기반 JavaScript 애플리케이션에 프론트엔드 전용 백엔드(Backend For Frontend; BFF) 패턴을 사용하는 경우, 액세스 토큰 및 리프레시 토큰은 백엔드에서만 접근 가능해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.1.2",
              "Ordinal": 2,
              "Description": "클라이언트는 인가 서버에서 제공하는 값(예: 인가 코드 또는 ID 토큰)이 동일한 사용자 에이전트 세션 및 트랜잭션에서 시작된 인가 플로우의 결과인 경우에만 허용하는지 검증해야 한다. 이를 위해 클라이언트가 생성하는 비밀 값(PKCE(Proof Key for Code Exchange)의 'code_verifier', 'state', OIDC의 'nonce' 등)은 추측이 불가능해야 하며, 해당 트랜잭션에 고유해야 하고, 트랜잭션이 시작된 클라이언트와 사용자 에이전트 세션 양쪽에 안전하게 결합(Binding)되어 있어야 한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V10.2",
          "Ordinal": 2,
          "Name": "OAuth 클라이언트",
          "Items": [
            {
              "Shortcode": "V10.2.1",
              "Ordinal": 1,
              "Description": "코드 플로우를 사용하는 경우, OAuth 클라이언트는 토큰 요청을 유도하는 사이트 간 요청 위조 공격(Cross-Site Request Forgery; CSRF)에 대한 보호 기능을 갖추고 있는지 검증한다. 이를 위해 인가 요청 시 전송된 'state' 파라미터를 검증하거나, PKCE 기능을 사용해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.2.2",
              "Ordinal": 2,
              "Description": "OAuth 클라이언트가 둘 이상의 인가 서버와 상호 작용할 수 있는 경우, 믹스업 공격에 대한 방어 대책을 갖는지 검증해야 한다. 예를 들어, 인가 서버가 'iss' 파라미터 값을 반환하도록 요구하고 인가 응답 및 토큰 응답에서 이를 검증할 수 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.2.3",
              "Ordinal": 3,
              "Description": "OAuth 클라이언트가 인가 서버에 대한 요청에서 필요한 범위(또는 기타 인가 파라미터)만 요청하는지 검증해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V10.3",
          "Ordinal": 3,
          "Name": "OAuth 리소스 서버",
          "Items": [
            {
              "Shortcode": "V10.3.1",
              "Ordinal": 1,
              "Description": "리소스 서버가 해당 서비스(audience)에 사용하도록 의도된 액세스 토큰만 수락하는지 검증해야 한다. 대상은 구조화된 액세스 토큰(예: JWT의 'aud' 클레임)에 포함될 수 있거나, 토큰 조회 엔드포인트를 사용하여 확인할 수 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.3.2",
              "Ordinal": 2,
              "Description": "리소스 서버가 위임된 인가를 정의하는 액세스 토큰의 클레임을 기반으로 인가 결정을 시행하는지 검증해야 한다. 'sub', 'scope', 'authorization_details'와 같은 클레임이 존재하는 경우, 이는 결정에 반영되어야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.3.3",
              "Ordinal": 3,
              "Description": "액세스 토큰(JWT 또는 관련 토큰 조회 응답)에서 고유한 사용자를 식별해야 하는 접근 제어 결정이 필요한 경우, 리소스 서버가 다른 사용자에게 재할당될 수 없는 클레임에서 사용자를 식별하는지 검증해야 한다. 일반적으로 이는 'iss' 및 'sub' 클레임의 조합을 사용하는 것을 의미한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.3.4",
              "Ordinal": 4,
              "Description": "리소스 서버가 특정 인증 강도, 방법 또는 최신성을 요구하는 경우, 제시된 액세스 토큰이 이러한 제약 조건을 충족하는지 검증해야 한다. 예를 들어, 토큰을 제시한 경우 OIDC의 'acr', 'amr' 및 'auth_time' 클레임을 각각 사용해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.3.5",
              "Ordinal": 5,
              "Description": "리소스 서버가 발신자 제약 액세스 토큰, 즉 OAuth 2용 상호 TLS(Mutual TLS; mTLS) 또는 OAuth 2 소유 증명(Demonstration of Proof of Possession; DPoP)를 요구하여 도난된 액세스 토큰 사용 또는 액세스 토큰 재사용(권한 없는 당사자로부터)을 방지하는지 검증해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V10.4",
          "Ordinal": 4,
          "Name": "OAuth 인가 서버",
          "Items": [
            {
              "Shortcode": "V10.4.1",
              "Ordinal": 1,
              "Description": "인가 서버는 클라이언트 별로 사전 등록된 URI의 허용 목록을 기반으로 리디렉션 URI를 정확한 문자열 비교 방식으로 검증해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V10.4.2",
              "Ordinal": 2,
              "Description": "인가 서버가 인가 응답에서 인가 코드를 반환하는 경우, 해당 코드는 토큰 요청에 한번만 사용될 수 있어야 한다. 이미 액세스 토큰을 발급하는 데 사용된 인가 코드를 사용하여 두 번째 요청이 발생하면, 인가 서버는 토큰 요청을 거부하고 해당 인가 코드와 관련된 모든 발급된 토큰을 취소해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V10.4.3",
              "Ordinal": 3,
              "Description": "인가 코드가 단기간만 유효한지 검증해야 한다. 최대 수명은 L1 및 L2 애플리케이션의 경우 최대 10분, L3 애플리케이션의 경우 최대 1분 이내여야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V10.4.4",
              "Ordinal": 4,
              "Description": "인가 서버는 특정 클라이언트에 대해, 해당 클라이언트가 사용할 필요가 있는 인가 방식(grant)만 사용하도록 허용해야 한다. token(암시적 플로우) 및 password(리소스 소유자 비밀번호 자격 증명 플로우) 방식은 더 이상 사용되어서는 안 된다.",
              "L": "1"
            },
            {
              "Shortcode": "V10.4.5",
              "Ordinal": 5,
              "Description": "인가 서버가 공개 클라이언트에 대한 리프레시 토큰 재사용 공격을 완화하는지 검증해야 한다. 가급적이면 발신자 제약 리프레시 토큰, 즉 소유 증명이나 mTLS를 사용한 인증서 바인딩 액세스 토큰을 사용해야 한다. L1 및 L2 애플리케이션의 경우, 리프레시 토큰 회전(rotation)이 사용될 수 있다. 리프레시 토큰 회전이 사용되는 경우, 인가 서버는 리프레시 토큰을 사용 후 무효화해야 하며, 이미 사용되고 무효화된 리프레시 토큰이 제공되면 해당 인가에 대한 모든 리프레시 토큰을 철회(revoke)해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V10.4.6",
              "Ordinal": 6,
              "Description": "코드 인가 방식(code grant)이 사용되는 경우, 인가 서버가 PKCE를 요구하여 인가 코드 탈취 공격을 완화하는지 검증해야 한다. 인가 요청의 경우, 인가 서버는 유효한 'code_challenge' 값을 요구해야 하며, 'code_challenge_method'값으로 'plain'를 허용해서는 안 된다. 토큰 요청의 경우, 'code_verifier' 파라미터의 검증을 요구해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.4.7",
              "Ordinal": 7,
              "Description": "인가 서버가 인증되지 않은 동적 클라이언트 등록을 지원하는 경우, 악의적인 클라이언트 애플리케이션의 위험을 완화하는지 검증해야 한다. 등록된 URI와 같은 클라이언트 메타데이터를 검증하고, 사용자의 동의를 확인해야 하며, 신뢰할 수 없는 클라이언트 애플리케이션으로 인가 요청을 처리하기 전에 사용자에게 경고해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.4.8",
              "Ordinal": 8,
              "Description": "슬라이딩 리프레시 토큰 만료(expiration)가 적용되더라도, 리프레시 토큰에 절대 만료 시점(absolute expiration)이 포함되어 있는지 확인한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.4.9",
              "Ordinal": 9,
              "Description": "악의적인 클라이언트 또는 도난된 토큰의 위험을 완화하기 위해 인가 서버 사용자 인터페이스를 통해 권한 있는 사용자가 리프레시 토큰 및 참조 액세스 토큰을 철회할 수 있는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.4.10",
              "Ordinal": 10,
              "Description": "토큰 요청, 푸시된 인가 요청(Pushed Authorization Request; PAR), 토큰 철회 요청과 같은 클라이언트에서 인가 서버로의 백채널 요청(backchannel request)에 대해 기밀 클라이언트가 인증되는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.4.11",
              "Ordinal": 11,
              "Description": "인가 서버 구성이 OAuth 클라이언트에 필요한 범위만 할당하는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.4.12",
              "Ordinal": 12,
              "Description": "주어진 클라이언트에 대해 인가 서버가 해당 클라이언트가 사용해야 하는 'response_mode' 값만 허용하는지 검증해야 한다. 예를 들어, 인가 서버가 이 값을 예상 값과 비교하여 검증하거나, PAR 또는 JWT 기반 인가 요청(JWT-secured Authorization Request; JAR)을 사용하여 검증해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V10.4.13",
              "Ordinal": 13,
              "Description": "인가 유형 'code'가 항상 PAR과 함께 사용되는지 검증해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V10.4.14",
              "Ordinal": 14,
              "Description": "인가 서버가 mTLS를 사용하는 인증서 바인딩 액세스 토큰 또는 소유 증명 바인딩 액세스 토큰을 사용하여 발신자 제약(Proof-of-Possession) 액세스 토큰만 발급하는지 검증해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V10.4.15",
              "Ordinal": 15,
              "Description": "최종 사용자 장치에서 실행되지 않는 서버에서 동작하는 클라이언트의 경우, 인가 서버가 'authorization_details' 파라미터 값이 클라이언트 백엔드로부터 생성되었는지와 사용자가 해당 값을 변조되지 않았는지를 검증해야 한다. 예를 들어, PAR 또는 JAR의 사용을 요구하여 확인해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V10.4.16",
              "Ordinal": 16,
              "Description": "클라이언트가 기밀 클라이언트인지 검증하고, 인가 서버는 재사용 공격에 강하고 공개키 암호화에 기반한 강력한 클라이언트 인증 방식을 사용하도록 요구해야 한다. 예를 들어, mTLS(tls_client_auth, self_signed_tls_client_auth) 또는 비공개 키 기반 JWT 인증(private_key_jwt) 등이 이에 해당한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V10.5",
          "Ordinal": 5,
          "Name": "OIDC 클라이언트",
          "Items": [
            {
              "Shortcode": "V10.5.1",
              "Ordinal": 1,
              "Description": "신뢰 당사자로서 클라이언트가 ID 토큰 재사용 공격을 완화하는지 검증해야 한다. 예를 들어, ID 토큰의 'nonce' 클레임이 OpenID 공급자에 전송된 인증 요청(OAuth2에서는 인가 서버에 전송된 인가 요청)에서 전송된 'nonce' 값과 일치하는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.5.2",
              "Ordinal": 2,
              "Description": "클라이언트가 ID 토큰 클레임, 일반적으로 'sub' 클레임에서 사용자를 고유하게 식별하며, 해당 클레임이 ID 공급자 범위 내에서 다른 사용자에게 재할당될 수 없는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.5.3",
              "Ordinal": 3,
              "Description": "클라이언트는 악의적인 인가 서버가 인가 서버 메타데이터를 통해 다른 인가 서버를 가장하려는 시도를 거부하는지 검증해야 한다. 클라이언트는 인가 서버 메타데이터에 포함된 발급자(issuer) URL이 클라이언트가 예상하는 사전 구성된 발급자 URL과 정확히 일치하지 않는 경우, 해당 메타데이터를 거부해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.5.4",
              "Ordinal": 4,
              "Description": "클라이언트는 토큰의 aud 클레임 값이 클라이언트의 client_id 값과 동일한지 확인하여 ID 토큰이 해당 클라이언트(audience)를 대상으로 발급되었음을 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.5.5",
              "Ordinal": 5,
              "Description": "OIDC 백채널 로그아웃을 사용하는 경우, 신뢰 당사자는 강제 로그아웃을 통한 서비스 거부 공격(Denial of Service) 및 로그아웃 플로우에서의 JWT 혼동(cross-JWT confusion)을 완화하는지 검증해야 한다. 클라이언트는 로그아웃 토큰이 'logout+jwt' 값으로 올바르게 지정되어 있는지, 올바른 멤버 이름을 가진 'event' 클레임을 포함하는지, 그리고 'nonce' 클레임을 포함하지 않는지 검증해야 한다. 또한, 짧은 만료 시간(예: 2분)을 갖는 것이 권장된다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V10.6",
          "Ordinal": 6,
          "Name": "OpenID 공급자",
          "Items": [
            {
              "Shortcode": "V10.6.1",
              "Ordinal": 1,
              "Description": "OpenID 공급자는 response_mode 파라미터 값으로'code', 'ciba', 'id_token' 또는 'id_token code' 만 허용하는지 검증해야 한다. 이 중 'id_token code'(OIDC 하이브리드 플로우)보다는 'code'가 선호되며, 'token'(모든 암시적 플로우)은 사용되어서는 안 된다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.6.2",
              "Ordinal": 2,
              "Description": "OpenID 공급자가 강제 로그아웃을 통한 서비스 거부 공격을 완화하는지 검증해야 한다. 신뢰 당사자로 부터 시작된 로그아웃 요청에 id_token_hint 등의 파라미터가 포함되어 있는 경우, 이를 검증하거나 최종 사용자로부터 명시적인 확인을 받아야 한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V10.7",
          "Ordinal": 7,
          "Name": "동의 관리",
          "Items": [
            {
              "Shortcode": "V10.7.1",
              "Ordinal": 1,
              "Description": "인가 서버가 사용자로부터 각 인가 요청에 대한 명시적인 동의(consent)를 확인하는지 검증해야 한다. 클라이언트의 신원을 보장할 수 없는 경우, 인가 서버는 항상 사용자에게 명시적으로 동의를 요청해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.7.2",
              "Ordinal": 2,
              "Description": "인가 서버가 사용자 동의를 요청할 때, 동의하는 내용에 대한 충분하고 명확한 정보를 제공하는지 검증해야 한다. 이에 해당하는 경우, 요청된 인가의 성격(일반적으로 범위, 리소스 서버, RAR(Rich Authorization Requests) 인가 세부 정보 기반), 인가된 애플리케이션의 신원, 인가의 유효 기간이 포함되어야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V10.7.3",
              "Ordinal": 3,
              "Description": "사용자가 인가 서버를 통해 부여한 동의를 검토, 수정 및 철회할 수 있는지 검증해야 한다.",
              "L": "2"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V11",
      "Ordinal": 11,
      "ShortName": "Cryptography",
      "Name": "암호화",
      "Items": [
        {
          "Shortcode": "V11.1",
          "Ordinal": 1,
          "Name": "암호화 인벤토리 및 문서화",
          "Items": [
            {
              "Shortcode": "V11.1.1",
              "Ordinal": 1,
              "Description": "'NIST SP 800-57'과 같은 암호화 키 관리 및 키 관리 표준을 따르는 암호화 키 수명 주기에 대한 문서화 된 정책이 있는지 검증해야 한다. 여기에는 키가 과도하게 공유되지 않도록 하는 것이 포함된다(예: 공유 비밀의 경우 두 개를 초과하는 엔터티와 공유 및 개인 키의 경우 한 개를 초과하는 엔터티에 공유).",
              "L": "2"
            },
            {
              "Shortcode": "V11.1.2",
              "Ordinal": 2,
              "Description": "애플리케이션에서 사용되는 모든 암호화 키, 알고리즘, 인증서를 포함한 암호화 자산 목록(cryptographic inventory)이 작성되고, 유지되며, 정기적으로 업데이트되고 있는지 검증해야 한다. 또한, 각 키가 시스템 내에서 사용 가능한 위치와 사용이 제한되는 위치, 해당 키로 보호할 수 있는 데이터 유형과 보호할 수 없는 데이터 유형이 문서화되어 있어야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V11.1.3",
              "Ordinal": 3,
              "Description": "암호화, 해싱, 서명 작업을 포함하는 시스템 내의 모든 암호화 사용 사례를 식별하기 위해, 암호화 사용 탐지 메커니즘이 적용되는지 검증해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V11.1.4",
              "Ordinal": 4,
              "Description": "암호화 자산 목록이 유지 관리되는지 검증해야 한다. 여기에는 미래의 위협에 대응하기 위해 양자 내성 암호(Post-Quantum Cryptography; PQC)와 같은 새로운 암호화 표준으로의 마이그레이션 계획을 설명하는 문서화된 계획이 포함되어야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V11.2",
          "Ordinal": 2,
          "Name": "안전한 암호화 구현",
          "Items": [
            {
              "Shortcode": "V11.2.1",
              "Ordinal": 1,
              "Description": "암호화 작업에 업계에서 검증된 구현(라이브러리 및 하드웨어 가속 구현 포함)이 사용되는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V11.2.2",
              "Ordinal": 2,
              "Description": "난수, 인증 암호화, MAC, 해싱 알고리즘, 키 길이, 라운드, 암호 및 모드를 언제든지 재구성, 업그레이드 또는 교체하여 암호화 해독으로부터 보호할 수 있도록 애플리케이션이 암호화 유연성(crypto agility)을 갖추고 설계되었는지 검증해야 한다. 또한, 키와 비밀번호를 교체하고 데이터를 다시 암호화하는 것도 가능해야 한다. 이를 통해 승인된 PQC 체계(또는 표준)의 고신뢰 구현이 널리 사용 가능해지면 PQC로 원활하게 업그레이드할 수 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V11.2.3",
              "Ordinal": 3,
              "Description": "모든 암호화 기본 구성요소(primitive)가 알고리즘, 키 크기 및 구성에 따라 최소 128비트의 보안강도를 제공하는지 검증해야 한다. 예를 들어, 256비트 ECC 키는 대략 128비트의 보안을 제공하며, RSA는 128비트의 보안을 달성하기 위해 3072비트 키를 필요로 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V11.2.4",
              "Ordinal": 4,
              "Description": "민감한 정보가 누출되는 것을 방지하기 위해 모든 암호화 연산은 상수 시간(constant-time)으로 수행되어야 하며, 비교, 계산, 반환 과정에서 단락(short-circuit) 연산이 없는지 검증해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V11.2.5",
              "Ordinal": 5,
              "Description": "모든 암호화 모듈이 안전하게 실패하고, 패딩 오라클 공격(Padding Oracle attacks)과 같은 취약점을 허용하지 않는 방식으로 오류가 처리되는지 검증해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V11.3",
          "Ordinal": 3,
          "Name": "암호화 알고리즘",
          "Items": [
            {
              "Shortcode": "V11.3.1",
              "Ordinal": 1,
              "Description": "안전하지 않은 블록 모드(예: ECB) 및 약한 패딩 방식(예: PKCS#1 v1.5)가 사용되지 않는지 검증해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V11.3.2",
              "Ordinal": 2,
              "Description": "GCM을 사용하는 AES와 같이 승인된 암호 및 모드만 사용되는지 검증해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V11.3.3",
              "Ordinal": 3,
              "Description": "암호화 된 데이터가 승인된 인증된 암호화 방식을 사용하거나, 승인된 암호화 방식과 승인된 MAC 알고리즘을 조합을 통한 무단 수정으로부터 보호되는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V11.3.4",
              "Ordinal": 4,
              "Description": "논스(nonces), 초기화 벡터 및 기타 단일 사용 번호가 둘 이상의 암호화 키 및 데이터 요소 쌍에 사용되지 않는지 검증해야 한다. 생성 방법은 사용되는 알고리즘에 적합해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V11.3.5",
              "Ordinal": 5,
              "Description": "암호화 알고리즘과 MAC 알고리즘의 모든 조합이 암호화 후 MAC(Encrypt-then-MAC) 방식으로 동작하는지 검증해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V11.4",
          "Ordinal": 4,
          "Name": "해싱 및 해시 기반 함수",
          "Items": [
            {
              "Shortcode": "V11.4.1",
              "Ordinal": 1,
              "Description": "디지털 서명, HMAC, KDF 및 무작위 비트 생성을 포함한 일반적인 암호화 사용 사례에 승인된 해시 함수만 사용되는지 검증해야 한다. MD5와 같이 허용되지 않는 해시 함수는 어떤 암호화 목적으로도 사용해서는 안 된다.",
              "L": "1"
            },
            {
              "Shortcode": "V11.4.2",
              "Ordinal": 2,
              "Description": "비밀번호가 승인된 '계산 집약적인 키 유도 함수(\"비밀번호 해싱 함수\"라고도 함)'를 사용하여 저장되고, 파라미터 설정이 현재 지침에 따라 구성되었는지 검증해야 한다. 설정은 필요한 보안 수준에 대한 무차별 대입 공격을 충분히 어렵게 만들기 위해 보안과 성능의 균형을 이루어야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V11.4.3",
              "Ordinal": 3,
              "Description": "데이터 인증 또는 데이터 무결성의 일부로 디지털 서명에 사용되는 해시 함수가 충돌 저항성을 가지며 적절한 비트 길이를 갖는지 검증해야 한다. 충돌 저항성이 필요한 경우, 출력 길이는 최소 256비트여야 한다. 제2 역상(pre-image) 공격 저항성만 필요한 경우, 출력 길이는 최소 128비트여야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V11.4.4",
              "Ordinal": 4,
              "Description": "비밀번호로부터 비밀 키를 유도할 때 애플리케이션이 키 스트레칭(key stretching) 파라미터를 사용하여 승인된 키 유도 함수(key derivation function)를 사용하는지 검증해야 한다. 사용 중인 파라미터는 결과적인 암호화 키를 손상시키는 무차별 대입 공격을 방지하기 위해 보안과 성능의 균형을 이루어야 한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V11.5",
          "Ordinal": 5,
          "Name": "무작위 값",
          "Items": [
            {
              "Shortcode": "V11.5.1",
              "Ordinal": 1,
              "Description": "예측 불가능해야 하는 모든 난수 및 문자열이 암호학적으로 안전한 의사 난수 생성기(CSPRNG)를 사용하여 생성되고 최소 128비트의 엔트로피를 갖는지 검증해야 한다. UUID는 이 조건을 충족하지 않는다.",
              "L": "2"
            },
            {
              "Shortcode": "V11.5.2",
              "Ordinal": 2,
              "Description": "사용 중인 난수 생성 메커니즘이 높은 부하(heavy demand)에서도 안전하게 작동하도록 설계되었는지 검증해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V11.6",
          "Ordinal": 6,
          "Name": "공개 키 암호화",
          "Items": [
            {
              "Shortcode": "V11.6.1",
              "Ordinal": 1,
              "Description": "키 생성 및 시딩, 디지털 서명 생성 및 검증에 승인된 암호화 알고리즘 및 작동 모드만 사용되는지 검증해야 한다. 키 생성 알고리즘은 알려진 공격에 취약한 안전하지 않은 키(예: 페르마 인수분해(Fermat factorization)에 취약한 RSA 키)를 생성해서는 안 된다.",
              "L": "2"
            },
            {
              "Shortcode": "V11.6.2",
              "Ordinal": 2,
              "Description": "키 교환에는 디피-헬만과 같은 승인된 암호화 알고리즘이 사용되어야 하며, 안전한 파라미터를 사용하는지 여부를 중점적으로 검증해야 한다.이는 중간자 공격(adversary-in-the-middle attacks) 또는 암호화 해독으로 이어질 수 있는 키 설정 프로세스에 대한 공격을 방지할 것이다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V11.7",
          "Ordinal": 7,
          "Name": "사용 중 데이터 암호화",
          "Items": [
            {
              "Shortcode": "V11.7.1",
              "Ordinal": 1,
              "Description": "사용 중인 민감한 데이터를 보호하고 무단 사용자 또는 프로세스의 접근을 방지하기 위해 전체 메모리 암호화가 사용되는지 검증해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V11.7.2",
              "Ordinal": 2,
              "Description": "데이터 최소화가 처리 중에 노출되는 데이터의 양을 최소화하고, 사용 직후 또는 가능한 한 빨리 데이터가 암호화되도록 보장하는지 검증해야 한다.",
              "L": "3"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V12",
      "Ordinal": 12,
      "ShortName": "Secure",
      "Name": "보안 통신",
      "Items": [
        {
          "Shortcode": "V12.1",
          "Ordinal": 1,
          "Name": "일반 TLS 보안 가이드",
          "Items": [
            {
              "Shortcode": "V12.1.1",
              "Ordinal": 1,
              "Description": "TLS 1.2 및 TLS 1.3과 같은 최신 권장 버전의 TLS 프로토콜만 활성화되어 있으며, 그중 최신 버전이 우선되어야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V12.1.2",
              "Ordinal": 2,
              "Description": "오직 권장되는 암호화 스위트(cipher suites)들이 활성화되어 있으며 그 중 가장 강력한 암호화 스위트로 우선 설정되어 있는지 확인한다. 레벨3 애플리케이션은 순방향 비밀성(forward secrecy)을 제공하는 암호화 스위트만 지원해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V12.1.3",
              "Ordinal": 3,
              "Description": "인증이나 권한 부여를 위해 인증서 ID를 사용하기 전에 애플리케이션이 mTLS 클라이언트 인증서가 신뢰할 수 있는지 검증해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V12.1.4",
              "Ordinal": 4,
              "Description": "Online Certificate Status Protocol (OCSP) 스테이플링(Stapling)과 같은 적절한 인증서 폐지 프로토콜이 활성화되고 설정되어 있는지 확인해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V12.1.5",
              "Ordinal": 5,
              "Description": "TLS 핸드셰이크 프로세스 중 Server Name Indication (SNI)과 같은 민감한 메타 데이터의 노출을 방지하기 위해 애플리케이션 TLS 설정에서 Encrypted Client Hello (ECH)가 활성화되어 있는지 확인해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V12.2",
          "Ordinal": 2,
          "Name": "외부 서비스와의 HTTPS 통신",
          "Items": [
            {
              "Shortcode": "V12.2.1",
              "Ordinal": 1,
              "Description": "TLS는 클라이언트와 외부 HTTP 기반 서비스 간의 모든 연결에 사용되며, 안전하지 않거나 암호화 되어 있지 않은 통신에 대체 동작(fall back)이 발생하지 않는지 확인해야한다. ",
              "L": "1"
            },
            {
              "Shortcode": "V12.2.2",
              "Ordinal": 2,
              "Description": "외부 서비스가 공적으로 신뢰된 TLS 인증서를 사용하는지 확인해야 한다.",
              "L": "1"
            }
          ]
        },
        {
          "Shortcode": "V12.3",
          "Ordinal": 3,
          "Name": "일반 서비스 간의 통신 보안",
          "Items": [
            {
              "Shortcode": "V12.3.1",
              "Ordinal": 1,
              "Description": "애플리케이션간의 모니터링 시스템, 관리 도구, 원격 엑세스 및 SSH, 미들웨어, 데이터베이스, 메인프레임, 파트너 시스템이나 외부 API를 포함한 모든 인바운드와 아웃바운드 통신은 TLS같은 암호화 프로토콜이 사용되는지 확인해야 한다. 이 서버는 안전하지 않거나 암호화 되어있지 않은 프로토콜에 대체 동작(fall back)이 발생하지 않아야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V12.3.2",
              "Ordinal": 2,
              "Description": "TLS 클라이언트가 통신하기 전에 TLS서버로 부터 받은 인증서를 검증하는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V12.3.3",
              "Ordinal": 3,
              "Description": "그리고 TLS 또는 애플리케이션 내의 내부 HTTP 기반 서비스간에 사용된 다른 적절한 전송 암호화 매커니즘이 안전하지 않거나 암호화 되어있지 않은 통신에 대체 동작(fall back)이 발생하지 않는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V12.3.4",
              "Ordinal": 4,
              "Description": "내부 서버간에 TLS 통신이 신뢰된 인증서를 사용하는지 확인해야 한다. 내부 인증서나 자체 서명(self-signed)인증서를 사용할 경우, 이를 사용하는 서비스는 오직 특정 내부 인증기관(CA)과 자체 서명 인증만을 신뢰하게 설정해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V12.3.5",
              "Ordinal": 5,
              "Description": "시스템 내부에서 통신하는 서비스(intra-service communication)는 각 엔드포인트를 검증하기 위해 강력한 인증을 사용해야 한다. 공용키(public-key) 기반 구조와 재전송 공격(replay attacks)에 저항하는 매커니즘을 사용하여 신원보장을 위해 TLS 클라이언트 인증과 같은 강력한 인증 방식을 사용해야 한다. 마이크로서비스 아키텍쳐의 경우 인증서 관리를 간소화 하고 보안을 강화하기 위해 서비스 매시(service mesh)를 사용하는 것을 고려해야 한다.",
              "L": "3"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V13",
      "Ordinal": 13,
      "ShortName": "Configuration",
      "Name": "설정",
      "Items": [
        {
          "Shortcode": "V13.1",
          "Ordinal": 1,
          "Name": "설정 문서",
          "Items": [
            {
              "Shortcode": "V13.1.1",
              "Ordinal": 1,
              "Description": "애플리케이션의 모든 통신 요구사항이 문서화 되어 있는지를 검증한다. 이는 애플리케이션이 의존하는 외부 서비스나, 사용자가 애플리케이션이 연결할 외부 위치를 제공하는 경우들을 포함한다.",
              "L": "2"
            },
            {
              "Shortcode": "V13.1.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 사용하는 각각의 서비스들에 대해, 문서가 최대 동시 연결 수(연결 풀 제한)를 정의하고 있는지, 그리고 그 한계에 다다랐을 때 폴백(fallback)이나 복구 메커니즘 등을 포함하여, DoS 공격을 방지하기 위해 애플리케이션이 어떻게 동작하는지를 검증한다.",
              "L": "3"
            },
            {
              "Shortcode": "V13.1.3",
              "Ordinal": 3,
              "Description": "애플리케이션 문서가 모든 외부 시스템이나 애플리케이션이 사용하는 서비스(예시: 데이터베이스, 파일 핸들, 스레드, HTTP 연결)들에 대한 자원-관리 전략을 정의하고 있는지 검증한다.이는 자원-해제 프로시저, 시간초과 설정, 오류 핸들링을 포함하며, 재시도 로직이 구현된 경우 재시도 제한과 지연, 백-오프 알고리즘을 명시해야 한다. 동기 HTTP 요청-응답 명령에 대해서는 짧은 타임아웃에 더해 재시도의 비활성화 혹은 연쇄적인 지연과 자원 고갈을 방지하기 위한 재시도의 엄격한 제한을 의무화해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V13.1.4",
              "Ordinal": 4,
              "Description": "애플리케이션 문서가 조직의 위협 모델과 사업적 요구사항에 기반하여, 애플리케이션의 보안과 비밀 정보들의 주기적 갱신 일정에 치명적인 비밀 정보들을 정의하고 있는지 검증한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V13.2",
          "Ordinal": 2,
          "Name": "백엔드 통신 설정",
          "Items": [
            {
              "Shortcode": "V13.2.1",
              "Ordinal": 1,
              "Description": "API나 미들웨어와 같은 애플리케이션의 표준 사용자 세션 메커니즘을 지원하지 않는 백엔드 애플리케이션 컴포넌트와 데이터 계층 사이의 통신이 인증되어 있는지를 검증한다. 인증은 반드시 개별적인 서비스 계정과 단기간 토큰, 또는 인증서 기반 인증을 사용하고 비밀번호, API 키, 또는 접근 권한이 부여된 공유 계정 등의 자격 증명을 변경하지 않아선 안 된다. ",
              "L": "2"
            },
            {
              "Shortcode": "V13.2.2",
              "Ordinal": 2,
              "Description": "로컬 또는 운영체제 서비스, API, 미들웨어, 그리고 데이터 계층을 포함한 백엔드 애플리케이션 컴포넌트 간의 통신이 최소 필요 권한이 할당된 계정들로 수행되는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V13.2.3",
              "Ordinal": 3,
              "Description": "만약 자격 증명이 서비스 인증을 위해 필요하다면, 소비자로부터 사용되는 그 자격 증명이 기본 자격 증명이 아님을 검증한다. (예시: root/root 또는 admin/admin)",
              "L": "2"
            },
            {
              "Shortcode": "V13.2.4",
              "Ordinal": 4,
              "Description": "얼로우리스트가 애플리케이션의 통신이 허가된 외부 리소스나 시스템을 정의하기 위해 사용되는지 검증한다. (예시: 아웃바운드 요청, 데이터 로드, 파일 접근). 이 얼로우리스트는 애플리케이션 계층, 웹 서버, 방화벽 또는 다른 여러 계층의 조합으로 구현할 수 있다.  ",
              "L": "2"
            },
            {
              "Shortcode": "V13.2.5",
              "Ordinal": 5,
              "Description": "웹이나 애플리케이션 서버에 요청을 보내거나 데이터나 파일을 로드 할 수 있는  리소스 또는 시스템의 얼로우리스트가 설정되어 있는지를 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V13.2.6",
              "Ordinal": 6,
              "Description": "애플리케이션이 별도의 서비스와 연결할 때, 각 연결이 최대 병렬연결, 최대 연결 도달 시의 동작, 연결 타임아웃, 재시도 전략 등 문서화된 설정에 따르는지 검증한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V13.3",
          "Ordinal": 3,
          "Name": "비밀 정보 관리",
          "Items": [
            {
              "Shortcode": "V13.3.1",
              "Ordinal": 1,
              "Description": "키 볼트와 같은 비밀 정보 관리 솔루션이 백엔드 비밀 정보들을 만들고 저장하고, 접근을 제어하고, 파기하기 위해 사용되고 있는지 검증한다. 이는 비밀번호, 키 재료, 데이터베이스와 서드 파티 시스템의 통합, 시간-기반 토큰을 위한 키와 시드, 그리고 API 키들을 포함할 수 있다. 비밀 정보들은 애플리케이션 소스 코드 내부나, 빌드 아티팩트에 포함되어서는 안 된다. L3 애플리케이션에 대해서는, 반드시 HSM과 같은 하드웨어 기반 솔루션을 사용해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V13.3.2",
              "Ordinal": 2,
              "Description": "비밀 정보 자원들에 대한 접근이 최소 권한의 원칙을 고수하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V13.3.3",
              "Ordinal": 3,
              "Description": "보안 모듈에 대한 외부의 노출로부터 안전하게 키 재료를 관리하고 보호하기 위해 모든 암호 연산이 고립된 보안 모듈(볼트나, 하드웨어 보안 모듈 등)을 사용하여 수행되는지 검증한다.",
              "L": "3"
            },
            {
              "Shortcode": "V13.3.4",
              "Ordinal": 4,
              "Description": "애플리케이션의 문서를 기반으로 비밀 정보들이 만료되고 갱신되도록 설정되었는지 검증한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V13.4",
          "Ordinal": 4,
          "Name": "의도하지 않은 정보 노출",
          "Items": [
            {
              "Shortcode": "V13.4.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 .git 이나 .svn 폴더 같은 소스 코드 관리 메타데이터 없이 배포되었는지, 또는 이 폴더들이 외부적으로든 애플리케이션 자체에서든 접근할 수 없도록 배포되었는지 검증한다. ",
              "L": "1"
            },
            {
              "Shortcode": "V13.4.2",
              "Ordinal": 2,
              "Description": "실제 운영환경에서 디버깅 기능 노출이나 정보 누출을 방지하기 위해, 모든 컴포넌트에서 디버그 모드가 비활성화되어 있는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V13.4.3",
              "Ordinal": 3,
              "Description": "분명히 의도된 것이 아닌 이상 웹 서버가 폴더 목록을 클라이언트에게 노출하지 않는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V13.4.4",
              "Ordinal": 4,
              "Description": "잠재적인 정보 누출을 방지하기 위해 실제 운영환경에서 HTTP TRACE 메소드 사용이 지원되지 않는지 검증한다. ",
              "L": "2"
            },
            {
              "Shortcode": "V13.4.5",
              "Ordinal": 5,
              "Description": "분명히 의도된 것이 아닌 이상 문서(내부 API 같은)와 모니터링 엔드포인트가 노출되지 않는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V13.4.6",
              "Ordinal": 6,
              "Description": "애플리케이션이 백엔드 컴포넌트의 자세한 버전 정보를 노출하지 않는지 검증한다.",
              "L": "3"
            },
            {
              "Shortcode": "V13.4.7",
              "Ordinal": 7,
              "Description": "웹 계층이 의도적이지 않은 정보, 설정, 소스코드 누출을 방지하기 위해 특정 파일 확장자만 서비스하도록 설정되었는지 검증한다.",
              "L": "3"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V14",
      "Ordinal": 14,
      "ShortName": "Data",
      "Name": "데이터 보호",
      "Items": [
        {
          "Shortcode": "V14.1",
          "Ordinal": 1,
          "Name": "데이터 보호 문서화",
          "Items": [
            {
              "Shortcode": "V14.1.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 생성하고 처리하는 모든 민감한 데이터가 식별되고 보호 수준으로 분류되었는지 확인한다. 여기에는 단순히 인코딩되어 있고 쉽게 디코딩할 수 있는 데이터, 예를 들어 Base64 문자열이나 JWT 내부 평문 페이로드가 포함된다. 보호 수준은 애플리케이션이 준수해야 하는 모든 데이터 보호 및 개인정보 보호 관련 규정과 표준을 반드시 고려해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V14.1.2",
              "Ordinal": 2,
              "Description": "모든 민감한 데이터의 보호 수준에 대해 문서화된 요구사항이 있는지 확인한다. 반드시 여기에는(이에 한정되지 않지만) 일반적인 암호화, 무결성 검증, 보존 기간, 데이터 로그 기록 방식, 로그 내 민감한 데이터에 대한 접근 제어, 데이터베이스 암호화 수준, 사용할 개인정보 보호 및 개인정보 보호 강화 기술, 그리고 기타 기밀성 요구사항들 관련하여 포함되어야 한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V14.2",
          "Ordinal": 2,
          "Name": "일반 데이터 보호",
          "Items": [
            {
              "Shortcode": "V14.2.1",
              "Ordinal": 1,
              "Description": "민감한 데이터는 HTTP 메시지 본문이나 헤더 필드로만 서버에 전송되고, URL과 쿼리 문자열에는 API키나 세션토큰처럼 민감한 정보가 포함되지 않도록 검증한다.",
              "L": "1"
            },
            {
              "Shortcode": "V14.2.2",
              "Ordinal": 2,
              "Description": "서버 구성 요소에서 로드밸런서나 애플리케이션 캐시와 같은 민감한 데이터가 캐시되지 않게 하거나, 사용 후 해당 데이터를 안전하게 삭제하도록 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V14.2.3",
              "Ordinal": 3,
              "Description": "정의된 민감한 데이터가 애플리케이션의 통제를 벗어난 곳에서 원치 않는 수집을 예방하기 위해 신뢰할 수 없는 대상(예: 사용자 추적기)에게 전송되지 않도록 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V14.2.4",
              "Ordinal": 4,
              "Description": "암호화, 무결성 검증, 보존, 데이터 로그 기록 방식, 로그 내 민감한 데이터 접근 제어, 개인정보 보호 및 개인정보 보호 강화 기술과 관련된 민감한 데이터 통제가, 해당 데이터 보호 수준에 대한 문서에 정의된 대로 구현되었는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V14.2.5",
              "Ordinal": 5,
              "Description": "캐시 메커니즘이 해당 리소스에 대해 예상되는 콘텐츠 유형을 가진 응답만 캐시하고, 민감하거나 동적인 콘텐츠는 캐시하지 않도록 구성되어 있는지 검증한다. 존재하지 않는 파일에 접근했을 때 다른 유효한 파일을 반환하는 대신 웹 서버는 404 또는 302 응답을 반환해야 한다. 이는 Web Cache Deception  공격을 예방한다.",
              "L": "3"
            },
            {
              "Shortcode": "V14.2.6",
              "Ordinal": 6,
              "Description": "애플리케이션 기능에 필요한 최소한의 민감한 데이터만 반환을 검증한다. 예를 들어, 전체 신용카드 번호가 아닌 일부 숫자만 반환해야 한다. 만약 전체 데이터가 필요한 경우, 사용자가 구체적으로 조회하지 않는 한 사용자 인터페이스에서는 마스킹하는 것이 권장된다.",
              "L": "3"
            },
            {
              "Shortcode": "V14.2.7",
              "Ordinal": 7,
              "Description": "민감한 정보는 데이터 보존 분류 기준에 따라 관리되어야 하고, 오래되었거나 불필요한 데이터는 사전에 정의된 작업 또는 상황에 따라 자동으로 삭제되도록 검증한다.",
              "L": "3"
            },
            {
              "Shortcode": "V14.2.8",
              "Ordinal": 8,
              "Description": "사용자가 제출한 파일의 메타데이터에서 사용자가 저장에 동의하지 않는 한 민감한 정보는 제거를 검증한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V14.3",
          "Ordinal": 3,
          "Name": "클라이언트 측 데이터 보호",
          "Items": [
            {
              "Shortcode": "V14.3.1",
              "Ordinal": 1,
              "Description": "클라이언트나 세션이 종료된 후에 브라우저 DOM과 같은 클라이언트 스토리지에서 인증된 데이터를 삭제되는지 검증한다. 이를 위해 ‘Clear-Site-Data’ HTTP 응답 헤더 필드를 사용할 수 있으나, 세션 종료 시 서버 연결이 불가능한 경우에도 클라이언트 측에서 해당 데이터를 삭제하는 것이 권장된다.",
              "L": "1"
            },
            {
              "Shortcode": "V14.3.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 브라우저에서 민감한 데이터가 캐시되지 않도록, (Cache-Control: no-store)충분한 캐시 방지 HTTP 응답 헤더 필드를 설정을 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V14.3.3",
              "Ordinal": 3,
              "Description": "브라우저 저장소(localStorage, sessionStorage, IndexedDB, 쿠키)에 저장되는 데이터에는 세션 토큰을 제외한 민감 데이터가 포함되지 않도록 검증한다.",
              "L": "2"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V15",
      "Ordinal": 15,
      "ShortName": "Secure",
      "Name": "보안 코딩 및 아키텍처",
      "Items": [
        {
          "Shortcode": "V15.1",
          "Ordinal": 1,
          "Name": "보안 코딩 및 아키텍처 문서화",
          "Items": [
            {
              "Shortcode": "V15.1.1",
              "Ordinal": 1,
              "Description": "애플리케이션 문서에 취약점이 존재하는 서드파티 구성요소 버전 및 일반적인 라이브러리 업데이트에 대해, 해당 구성요소로부터 발생할 수 있는 위험을 최소화하기 위한 위험 기반 대응 기한이 정의되어 있는지 확인해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V15.1.2",
              "Ordinal": 2,
              "Description": "사용 중인 모든 서드파티 라이브러리에 대해 소프트웨어 자재 명세서(SBOM)와 같은 인벤토리가 유지되고 있으며, 해당 구성요소가 사전에 정의된 신뢰할 수 있고 지속적으로 관리되는 저장소에서 제공되는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V15.1.3",
              "Ordinal": 3,
              "Description": "애플리케이션 문서에 시간 소모가 크거나 리소스 소비가 많은 기능이 식별되어 있으며, 해당 기능의 과도한 사용으로 인해 가용성이 손실되지 않도록 하는 방법과, 응답 생성이 소비자의 타임아웃보다 오래 걸리는 상황을 방지하는 방법이 포함되어 있는지 확인해야 한다. 가능한 방어 전략에는 비동기 처리, 큐(queue) 사용, 사용자 및 애플리케이션 단위의 병렬 처리 제한 등이 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V15.1.4",
              "Ordinal": 4,
              "Description": "애플리케이션 문서에 위험한 구성요소로 간주되는 서드파티 라이브러리가 강조되어 있는지 확인해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V15.1.5",
              "Ordinal": 5,
              "Description": "애플리케이션 문서에 위험한 기능을 사용하는 애플리케이션의 부분이 강조되어 있는지 확인해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V15.2",
          "Ordinal": 2,
          "Name": "보안 아키텍처 및 종속성",
          "Items": [
            {
              "Shortcode": "V15.2.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 문서화된 업데이트 및 대응 기한을 위반하지 않은 구성요소만 포함하고 있는지 확인해야 한다.",
              "L": "1"
            },
            {
              "Shortcode": "V15.2.2",
              "Ordinal": 2,
              "Description": "애플리케이션이 시간 소모가 크거나 리소스 소비가 많은 기능의 과도한 사용으로 인한 가용성 손실을 방지하기 위해, 해당 기능에 대한 문서화된 보안 결정 및 전략을 기반으로 방어 조치를 구현하고 있는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V15.2.3",
              "Ordinal": 3,
              "Description": "운영 환경에 애플리케이션 기능 수행에 필요한 기능만 포함되어 있으며, 테스트 코드, 샘플 코드, 개발용 기능 등 불필요한 기능이 노출되지 않도록 구성되어 있는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V15.2.4",
              "Ordinal": 4,
              "Description": "서드파티 구성요소 및 그 모든 전이 종속성(transitive dependencies)이 내부 또는 외부의 예상된 저장소에서 가져며, 의존성 혼동(dependency confusion) 공격의 위험이 없는지 확인해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V15.2.5",
              "Ordinal": 5,
              "Description": "애플리케이션이 위험한 기능을 포함하거나 위험한 구성요소를 사용하는 부분에 대해 샌드박싱, 캡슐화, 컨테이너화, 네트워크 수준 격리와 같은 추가적인 보호 기법을 구현하여, 애플리케이션의 한 부분이 침해되더라도 공격자가 다른 영역으로 확산하지 못하도록 지연 및 차단하고 있는지 확인해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V15.3",
          "Ordinal": 3,
          "Name": "방어적(Defensive) 코딩",
          "Items": [
            {
              "Shortcode": "V15.3.1",
              "Ordinal": 1,
              "Description": "애플리케이션이 데이터 객체에서 필요한 필드만 선택적으로 반환하고 있는지 확인해야 한다. 예를 들어, 일부 필드는 사용자에게 노출되어서는 안 되므로 전체 데이터 객체를 반환해서는 안 된다.",
              "L": "1"
            },
            {
              "Shortcode": "V15.3.2",
              "Ordinal": 2,
              "Description": "애플리케이션 백엔드에서 외부 URL로 요청을 보낼 때, 의도된 기능이 아닌 경우 리디렉션을 따르지 않도록 구성되어 있는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V15.3.3",
              "Ordinal": 3,
              "Description": "애플리케이션이 각 컨트롤러 및 액션 단위로 허용된 필드를 제한함으로써, 대량 할당(mass assignment) 공격에 대한 방어가 구현되어 있는지 확인해야 한다. 예를 들어, 특정 동작에 포함되지 않은 필드 값을 삽입하거나 수정할 수 없어야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V15.3.4",
              "Ordinal": 4,
              "Description": "모든 프록시 및 미들웨어 구성요소가 사용자의 원래 IP 주소를 신뢰 가능한 데이터 필드를 통해 정확하게 전달하고 있으며, 애플리케이션과 웹 서버가 이 값을 로그 기록이나 속도 제한(rate limiting)과 같은 보안 결정에 사용하는지 확인해야 한다. 단, 동적 IP, VPN, 방화벽 등으로 인해 원래 IP조차 완전히 신뢰할 수 없는 점도 고려해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V15.3.5",
              "Ordinal": 5,
              "Description": "애플리케이션이 변수의 타입이 올바른지 명시적으로 확인하고, 엄격한 동등성 비교 및 연산자를 사용하여 타입 혼용(type juggling) 또는 타입 혼동(type confusion)으로 인한 취약점을 방지하고 있는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V15.3.6",
              "Ordinal": 6,
              "Description": "JavaScript 코드가 프로토타입 오염(prototype pollution)을 방지할 수 있도록 작성되어 있는지 확인해야 한다. 예를 들어, 객체 리터럴 대신 `Set()` 또는 `Map()`을 사용하는 방식이 권장된다.",
              "L": "2"
            },
            {
              "Shortcode": "V15.3.7",
              "Ordinal": 7,
              "Description": "애플리케이션이 HTTP 파라미터 오염(HTTP parameter pollution) 공격에 대한 방어를 구현하고 있는지 확인해야 한다. 특히, 애플리케이션 프레임워크가 요청 파라미터의 출처(쿼리 스트링, 본문, 쿠키, 헤더)를 구분하지 않는 경우 이를 고려해야 한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V15.4",
          "Ordinal": 4,
          "Name": "안전한 동시성",
          "Items": [
            {
              "Shortcode": "V15.4.1",
              "Ordinal": 1,
              "Description": "다중 스레드 코드에서 캐시, 파일, 다수 스레드가 접근하는 메모리 내 객체 등 공유 객체에 접근할 때, 스레드 세이프(thread-safe) 타입과 락·세마포어 같은 동기화 메커니즘을 사용하여 경쟁 상태와 데이터 손상을 피하고 안전하게 접근하는지 확인해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V15.4.2",
              "Ordinal": 2,
              "Description": "리소스의 존재 여부나 권한과 같은 상태 검사와, 그 검사 결과에 의존하는 동작이 단일(atomic) 연산으로 수행되어 TOCTOU 경쟁 상태를 방지하는지 확인해야 한다. (예: 파일을 열기 전에 존재 여부를 확인하는 작업과 파일 열기 동작을 분리하지 않기, 접근 권한 검증과 권한 부여를 동일 트랜잭션/원자적 구간에서 수행하기)",
              "L": "3"
            },
            {
              "Shortcode": "V15.4.3",
              "Ordinal": 3,
              "Description": "스레드가 서로를 기다리거나 무한 재시도에 빠지지 않도록 일관된 락 사용을 보장하고, 락 관리 로직을 리소스 관리 책임 코드 내부에 유지하여 외부 클래스 및 코드가 우발적·악의적으로 락을 변경하지 못하도록 하는지 확인해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V15.4.4",
              "Ordinal": 4,
              "Description": "**스레드 풀** 활용 등 **리소스 할당 정책**을 통해 공정한 리소스 접근을 보장하고, 우선순위가 낮은 스레드도 합리적 시간 내 진행될 수 있게 하여 **스레드 기아**를 방지하는지 확인해야 한다.",
              "L": "3"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V16",
      "Ordinal": 16,
      "ShortName": "Security",
      "Name": "보안 로깅과 오류 처리",
      "Items": [
        {
          "Shortcode": "V16.1",
          "Ordinal": 1,
          "Name": "보안 로깅 문서화",
          "Items": [
            {
              "Shortcode": "V16.1.1",
              "Ordinal": 1,
              "Description": "애플리케이션의 기술 스택의 각 계층에서 수행된 로깅에 대해, 어떤 이벤트들이 로그로 남았는지, 로그의 형식이 무엇인지, 로그가 어디에 저장되었는지, 어떻게 사용되는지, 로그에 대한 접근이 어떻게 제어되는지, 그리고 로그가 얼마나 보관되는지에 대해 문서화한 목록이 존재하는지 검증한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V16.2",
          "Ordinal": 2,
          "Name": "일반 로깅",
          "Items": [
            {
              "Shortcode": "V16.2.1",
              "Ordinal": 1,
              "Description": "이벤트가 발생했을 때 그 타임라인을 자세히 조사할 수 있도록 각 로그의 항목이 필수적인 메타데이터(언제, 어디서, 누가, 무엇을 등)을 포함하는지 검증한다. ",
              "L": "2"
            },
            {
              "Shortcode": "V16.2.2",
              "Ordinal": 2,
              "Description": "모든 로깅 컴포넌트의 시간 소스가 동기화되어 있는지, 그리고 보안 이벤트 메타데이터에서 타임스탬프가 UTC를 사용하거나 혹은 명시적인 시간대 오프셋을 포함하는지 검증한다. UTC는 분산 시스템 전체에 걸친 일관성을 보장하고, 일광 절약 시간제 전환 시의 혼란을 방지하기 위해 추천된다.",
              "L": "2"
            },
            {
              "Shortcode": "V16.2.3",
              "Ordinal": 3,
              "Description": "애플리케이션이 로그를 저장만 하는지, 혹은 로그 목록에서 문서화 된 파일이나 서비스로 브로드캐스트하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V16.2.4",
              "Ordinal": 4,
              "Description": "사용 중인 로그 처리기가 로그를 읽고, 또 상호 연관 지을 수 있는지 검증한다. 가능하다면 공통 로깅 형식을 사용하는 것이 좋다.",
              "L": "2"
            },
            {
              "Shortcode": "V16.2.5",
              "Ordinal": 5,
              "Description": "민감한 데이터를 로깅할때, 애플리케이션이 데이터의 보호 수준을 기반으로 로깅을 수행하는지 검증한다. 예를 들어, 자격 증명이나, 지불 상세 정보 등의 특정 데이터는 로깅 해서는 안 된다. 또한 세션 토큰 등의 데이터는 전체 혹은 일부분이 해싱된, 마스킹 된 상태로 로깅 되어야 한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V16.3",
          "Ordinal": 3,
          "Name": "보안 이벤트",
          "Items": [
            {
              "Shortcode": "V16.3.1",
              "Ordinal": 1,
              "Description": "성공한 시도와 실패한 시도를 포함하여 모든 인증 명령을 로깅 하는지 검증한다. 인증의 종류나, 사용한 인증 요소 등의 추가적인 메타데이터 또한 수집해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V16.3.2",
              "Ordinal": 2,
              "Description": "실패한 인가 시도들도 로깅 하는지 검증한다. L3에 대해서는 반드시 민감한 데이터가 접근되었을 때를 포함하여(민감한 데이터 자체는 제외하고) 모든 인가 결정들의 로그를 포함해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V16.3.3",
              "Ordinal": 3,
              "Description": "애플리케이션이 이 문서에서 정의한 보안 이벤트들을 로깅하고, 또한 입력값 확인, 비즈니스 로직, 그리고 자동화 방지 등의 보안 제어를 우회하려는 시도들도 로깅 하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V16.3.4",
              "Ordinal": 4,
              "Description": "애플리케이션이 백엔드 TLS 오류와 같은 예상치 못한 오류나 보안 제어 오류들을 로깅 하는지 검증한다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V16.4",
          "Ordinal": 4,
          "Name": "로그 보호",
          "Items": [
            {
              "Shortcode": "V16.4.1",
              "Ordinal": 1,
              "Description": "로그 삽입을 방지하기 위해 모든 로깅 컴포넌트가 적절히 데이터를 인코딩하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V16.4.2",
              "Ordinal": 2,
              "Description": "로그가 비인가된 접근으로부터 보호되고 수정할 수 없는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V16.4.3",
              "Ordinal": 3,
              "Description": "분석, 탐지, 경보, 그리고 에스컬레이션(escalation)을 위해 로그가 논리적으로 분리된 시스템으로 안전하게 전송되는지 검증한다. 애플리케이션이 침해되더라도 로그는 훼손하지 못하도록 보장하는 것이 목적이다.",
              "L": "2"
            }
          ]
        },
        {
          "Shortcode": "V16.5",
          "Ordinal": 5,
          "Name": "오류 처리",
          "Items": [
            {
              "Shortcode": "V16.5.1",
              "Ordinal": 1,
              "Description": "예상치 못한 혹은 보안 측면에서 민감한 오류가 발생했을 때 스택 흔적, 쿼리, 비밀키, 그리고 토큰 등의 민감한 내부 시스템 데이터의 노출 방지를 보장하기 위해 유저에게 구체화하지 않은 메시지를 반환하는지 검증한다.",
              "L": "2"
            },
            {
              "Shortcode": "V16.5.2",
              "Ordinal": 2,
              "Description": "외부 리소스 접근 오류가 발생하더라도 애플리케이션이 계속해서 안전하게 작동하는지 검증한다. 예를 들어 서킷 브레이커(circuit breaker)나 우아한 성능 저하와 같은 패턴을 사용할 수 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V16.5.3",
              "Ordinal": 3,
              "Description": "예외가 발생할 때, 검증 로직의 오류에도 불구하고 거래를 처리하는 등의 페일-오픈(fail-open) 상태 방지를 포함하여 애플리케이션이 우아하고 안전하게 실패하는지 검증한다. ",
              "L": "2"
            },
            {
              "Shortcode": "V16.5.4",
              "Ordinal": 4,
              "Description": "처리되지 못한 모든 예외를 처리할 “최후의 수단” 오류 핸들러가 정의되어 있는지 검증한다. 이는 로그 파일에 기록되어야 하는 오류 상세 정보들의 손실을 피하기 위함과 동시에, 오류로 인해 전체 애플리케이션 프로세스가 종료되어 가용성 손실로 이어지지 않도록 보장하기 위함이다. ",
              "L": "3"
            }
          ]
        }
      ]
    },
    {
      "Shortcode": "V17",
      "Ordinal": 17,
      "ShortName": "WebRTC",
      "Name": "WebRTC",
      "Items": [
        {
          "Shortcode": "V17.1",
          "Ordinal": 1,
          "Name": "TURN 서버",
          "Items": [
            {
              "Shortcode": "V17.1.1",
              "Ordinal": 1,
              "Description": "Traversal Using Relays around NAT(TURN) 서비스가 특정 목적을 위해 보존된 주소(예: 내부 네트워크, 브로드캐스트, 루프백)를 제외한 주소에 대해서만 접근을 허용하도록 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V17.1.2",
              "Ordinal": 2,
              "Description": "Traversal Using Relays around NAT(TURN) 서비스가 정당한 사용자의 TURN 서버 포트의 대량 개방 시 자원고갈에 취약하지 않도록 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V17.2",
          "Ordinal": 2,
          "Name": "미디어",
          "Items": [
            {
              "Shortcode": "V17.2.1",
              "Ordinal": 1,
              "Description": "데이터그램 전송 계층 보안(DTLS) 인증서의 키가 암호화 키 관리에 대한 문서화된 정책에 따라 관리되고 보호되는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V17.2.2",
              "Ordinal": 2,
              "Description": "미디어 서버가 승인된 데이터그램 전송 계층 보안(DTLS) 암호 모음을 사용하고 지원하도록 구성되었는지, 그리고 보안 실시간 전송 프로토콜(DTLS-SRTP)을 위한 키 생성에 사용되는 DTLS 확장을 위한 안전한 보호 프로파일을 구성했는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V17.2.3",
              "Ordinal": 3,
              "Description": "미디어 서버에서 보안 실시간 전송 프로토콜(SRTP) 인증이 선택되어 있는지 확인한다. 이를 통해 실시간 전송 프로토콜(RTP) 삽입 공격으로 인한 서비스 거부 상태 발생 또는 오디오/비디오 미디어가 미디어 스트림에 삽입되는 것을 방지할 수 있다.",
              "L": "2"
            },
            {
              "Shortcode": "V17.2.4",
              "Ordinal": 4,
              "Description": "미디어 서버가 잘못된 형식의 보안 실시간 전송 프로토콜(SRTP) 패킷을 접했을 때도 수신 미디어 트래픽 처리를 계속할 수 있는지 확인해야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V17.2.5",
              "Ordinal": 5,
              "Description": "미디어 서버가 정상 사용자로부터의 보안 실시간 전송 프로토콜(SRTP) 패킷이 대량으로 유입되는 상황에서도 수신 미디어 트래픽 처리를 계속할 수 있는지 확인해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V17.2.6",
              "Ordinal": 6,
              "Description": "미디어 서버가 Datagram Transport Layer Security(DTLS)의 “ClientHello” 경합 조건 취약점에 노출되지 않았는지 확인해야 한다. 이를 위해 해당 미디어 서버가 공개적으로 취약한 것으로 알려져 있는지 확인하거나 경합 조건 테스트를 수행해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V17.2.7",
              "Ordinal": 7,
              "Description": "미디어 서버와 연결된 모든 오디오 또는 비디오 녹화 장치가 합법적인 사용자로부터의 보안 실시간 전송 프로토콜(SRTP) 패킷이 대량으로 유입되는 상황에서도 수신 미디어 트래픽 처리를 계속할 수 있는지 확인해야 한다.",
              "L": "3"
            },
            {
              "Shortcode": "V17.2.8",
              "Ordinal": 8,
              "Description": "데이터그램 전송 계층 보안(DTLS) 인증서가 세션 설명 프로토콜(SDP) 지문 속성과 대조되어 검증되었는지 확인하고, 검증이 실패할 경우 미디어 스트림을 종료하여 미디어 스트림의 진위성을 보장해야 한다.",
              "L": "3"
            }
          ]
        },
        {
          "Shortcode": "V17.3",
          "Ordinal": 3,
          "Name": "신호 처리",
          "Items": [
            {
              "Shortcode": "V17.3.1",
              "Ordinal": 1,
              "Description": "신호 서버가 플러드 공격 중에도 합법적인 수신 신호 메시지 처리를 계속할 수 있는지 확인해야 한다. 이는 신호 수준에서 속도 제한을 구현함으로써 달성되어야 한다.",
              "L": "2"
            },
            {
              "Shortcode": "V17.3.2",
              "Ordinal": 2,
              "Description": "서비스 거부 상태를 유발할 수 있는 잘못된 형식의 신호 메시지를 접했을 때 신호 서버가 정상적인 신호 메시지 처리를 계속할 수 있는지 확인해야 한다. 여기에는 입력 검증 구현, 정수 오버플로우 안전 처리, 버퍼 오버플로우 방지 및 기타 강력한 오류 처리 기법 적용이 포함될 수 있다.",
              "L": "2"
            }
          ]
        }
      ]
    }
  ]
}
