# V1 Кодировка и нейтрализация

## Задачи контроля

В этой главе рассматриваются наиболее распространенные уязвимости безопасности веб-приложений, связанные с небезопасной обработкой недоверенных (пользовательских) данных. Такие уязвимости могут привести к различным техническим уязвимостям, где такие данные интерпретируются в соответствии с правилами синтаксиса соответствующего интерпретатора.

Для современных веб-приложений всегда лучше использовать более архитектурно безопасные API, такие как параметризованные запросы, автоматическое экранирование или шаблонные фреймворки. В ином случае, самостоятельное тщательное выполнение кодирования выходных данных, экранирование или нейтрализация становятся критически важными для безопасности приложения.

Валидация входных данных служит механизмом многослойной/глубокоэшелонированной (defense‑in‑depth) защиты от неожидаемого или опасного контента. Однако, поскольку ее основная цель заключается в обеспечении соответствия входящих данных функциональным и бизнес-ожиданиям, требования, связанные с этим, можно найти в главе «Валидация и бизнес-логика».

## V1.1 Архитектура кодировки и нейтрализации

В разделах ниже приведены требования для синтаксиса или интерпретатора, предназначенные для безопасной обработки небезопасного содержимого и предотвращения уязвимостей безопасности. Требования в этом разделе охватывают порядок, в котором должна происходить эта обработка, и где она должна происходить. Они также направлены на то, чтобы гарантировать, что при каждом сохранении данных они остаются в своем исходном состоянии и не хранятся в закодированной или экранированной форме (например, кодировка HTML), чтобы предотвратить проблемы с двойным кодированием.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **1.1.1** | Убедитесь, что входные данные декодируются или деэкранируются в каноническую форму (в стандартное представление) только один раз. Декодирование происходит только тогда, когда ожидаются закодированные данные в этой форме, и что это делается перед дальнейшей обработкой входных данных, например, это не выполняется после проверки или нейтрализации. | 2 |
| **1.1.2** | Убедитесь, что приложение выполняет кодирование и экранирование выходных данных либо в качестве последнего шага перед использованием интерпретатором, для которого оно предназначено, либо самим интерпретатором. | 2 |

## V1.2 Предотвращение инъекций

Кодирование или экранирование выходных данных, выполняемое близко или смежно с потенциально опасным контекстом, критично для безопасности любого приложения. Обычно кодирование и экранирование выходных данных не сохраняется, а вместо этого используется для обеспечения безопасности выходных данных для немедленного использования в соответствующем интерпретаторе. Попытка выполнить это на более ранних этапах может привести к искажению содержимого или неэффективно отобразить кодирование или экранирование.

Во многих случаях библиотеки программного обеспечения включают более или полностью безопасные функции, которые выполняют это автоматически, хотя необходимо убедиться, что они корректны для текущего контекста.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **1.2.1** | Убедитесь, что выходная кодировка для ответа HTTP, документа HTML или документа XML соответствует требуемому контексту, например, кодировка соответствующих символов для элементов HTML, атрибутов HTML, комментариев HTML, CSS или полей заголовка HTTP делается таким способом, чтобы избежать изменения структуры сообщения или документа. | 1 |
| **1.2.2** | Убедитесь, что при динамическом построении URL-адресов недоверенные данные кодируются в соответствии с их контекстом (например, кодирование URL-адресов или кодирование base64url для query или path параметров или пути). Убедитесь, что разрешены только безопасные протоколы URL-адресов (например, запрещен javascript: или data:). | 1 |
| **1.2.3** | Убедитесь, что при динамическом построении содержимого JavaScript (включая JSON) используется кодирование или экранирование выходных данных, чтобы избежать изменения структуры сообщения или документа (чтобы избежать JavaScript и JSON-инъекций). | 1 |
| **1.2.4** | Убедитесь, что выборка данных (Redis, Memcached, чтение из файлов, обращение по API) или запросы к базе данных (например, SQL, HQL, NoSQL, Cypher) используют параметризованные запросы, ORM, Entity Frameworks или иным образом защищены от SQL-инъекций и других атак. Это также актуально при написании хранимых процедур. | 1 |
| **1.2.5** | Убедитесь, что приложение защищено от внедрения команд ОС и что вызовы операционной системы используют параметризованные запросы к ОС или используют контекстное кодирование вывода командной строки. | 1 |
| **1.2.6** | Убедитесь, что приложение защищено от LDAP-инъекций, или что реализованы специальные меры безопасности для их предотвращения. | 2 |
| **1.2.7** | Убедитесь, что приложение защищено от атак с использованием XPath-инъекций с помощью параметризации запросов или предварительно скомпилированных запросов. | 2 |
| **1.2.8** | Убедитесь, что процессоры LaTeX настроены безопасно (например, не используется флаг «–shell‑escape») и используется разрешенный список команд для предотвращения LaTeX-инъекций. | 2 |
| **1.2.9** | Убедитесь, что приложение экранирует специальные символы в регулярных выражениях (обычно с помощью обратной косой черты), чтобы предотвратить их ошибочную интерпретацию как метасимволов. | 2 |
| **1.2.10** | Убедитесь, что приложение защищено от внедрения формул CSV (CSV Injection). Приложение должно следовать правилам экранирования, определенным в RFC 4180, разделы 2.6 и 2.7, при экспорте содержимого CSV. Кроме того, при экспорте в CSV или другие форматы электронных таблиц (такие как XLS, XLSX или ODF) специальные символы (включая '=', '+', '-', '@', '\t' (табуляция), и '\0' (нулевой символ)) должны экранироваться одинарной кавычкой, если они появляются в качестве первого символа в значении поля. | 3 |

Примечание: Использование параметризованных запросов или экранирование SQL не всегда достаточно. Части запроса, такие как имена таблиц и столбцов (включая имена столбцов «ORDER BY»), не могут быть экранированы. Включение экранированных пользовательских данных в эти поля приводит к сбоям запросов или SQL-инъекции.

## V1.3 Нейтрализация

Идеальной защитой от использования недоверенных данных в небезопасном контексте является использование контекстно-зависимого кодирования или экранирования, которое сохраняет то же семантическое значение небезопасного контента, но делает его безопасным для использования в этом конкретном контексте, как обсуждалось более подробно в предыдущем разделе.

Если это невозможно, необходима нейтрализация, удаляющая потенциально опасные символы или данные. В некоторых случаях это может изменить семантическое значение ввода, но по соображениям безопасности альтернативы может не быть.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **1.3.1** | Убедитесь, что все ненадежные входные данные HTML из редакторов WYSIWYG или аналогичных программ нейтрализуются с помощью известных и безопасных библиотек или функций фреймворка для санитизации HTML. | 1 |
| **1.3.2** | Убедитесь, что приложение избегает использования eval() или других динамических функций выполнения кода, таких как Spring Expression Language (SpEL). Если нет альтернативы, любой пользовательский ввод должен быть нейтрализован перед выполнением. | 1 |
| **1.3.3** | Убедитесь, что данные, передаваемые в потенциально опасный контекст, предварительно нейтрализованы, чтобы обеспечить соблюдение мер безопасности, таких как разрешение только тех символов, которые безопасны для данного контекста, и обрезка слишком длинного ввода. | 2 |
| **1.3.4** | Убедитесь, что предоставленный пользователем файл .SVG проверен или нейтрализован, чтобы он содержал только теги и атрибуты (например, относящиеся к рисованию), которые безопасны для приложения, например, не содержат скриптов и foreignObject. | 2 |
| **1.3.5** | Убедитесь, что приложение нейтралует или отключает предоставленные пользователем скриптовые данные или выражения шаблонных языков, такие как таблицы стилей Markdown, CSS или XSL, BBCode или аналогичные. | 2 |
| **1.3.6** | Убедитесь, что приложение защищено от атак с подделкой запросов на стороне сервера (SSRF), проверяя ненадежные данные по разрешенному списку протоколов, доменов, путей и портов, а также нейтрализуя потенциально опасные символы перед использованием данных для вызова другой службы. | 2 |
| **1.3.7** | Убедитесь, что приложение защищено от атак с внедрением шаблонов (template injection), не позволяя создавать шаблоны на основе недоверенных входных данных. Если нет альтернативы, любые недоверенные входные данные, включаемые динамически во время создания шаблона, должны быть нейтрализованы или тщательно провалидированы. | 2 |
| **1.3.8** | Убедитесь, что приложение надлежащим образом нейтрализует недоверенные входные данные перед использованием в запросах Java Naming and Directory Interface (JNDI) и что JNDI настроен безопасно для предотвращения атак с использованием JNDI-инъекций. | 2 |
| **1.3.9** | Убедитесь, что приложение нейтрализует данные перед отправкой в Memcache, чтобы предотвратить атаки методом инъекций. | 2 |
| **1.3.10** | Убедитесь, что строки форматирования, которые могут быть использованы неожидаемым или вредоносным образом, нейтрализуются перед дальнейшим использованием. | 2 |
| **1.3.11** | Убедитесь, что приложение нейтрализует вводимые пользователем данные перед передачей в почтовые системы для защиты от SMTP или IMAP-инъекций. | 2 |
| **1.3.12** | Убедитесь, что регулярные выражения не содержат элементов, вызывающих экспоненциальный возврат, и убедитесь в нейтрализации недоверенных входных данных для предотвращения атак ReDoS или Runaway Regex. | 3 |

## V1.4 Память, строки и неуправляемый код

Следующие требования касаются рисков, связанных с небезопасным использованием памяти, которые обычно применяются, когда приложение использует системный язык или неуправляемый код.

В некоторых случаях этого можно добиться, установив флаги компилятора, которые включают защиту от переполнения буфера и предупреждения, включая рандомизацию стека и предотвращение выполнения данных, и которые прерывают сборку, если обнаружены небезопасные операции с указателем, памятью, строкой формата, целым числом или строкой.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **1.4.1** | Убедитесь, что для обнаружения или предотвращения ситуаций переполнения стека, буфера или кучи приложение учитывает размер доступной области памяти при строковых операциях, копировании в память, в арифметике указателей и т.п. | 2 |
| **1.4.2** | Убедитесь, что для предотвращения целочисленного переполнения применяется контроль знака, диапазона и типа допустимых входных данных. | 2 |
| **1.4.3** | Убедитесь, что динамически выделенная память и ресурсы освобождены, а ссылки или указатели на освобожденную память удалены или установлены в значение null, чтобы предотвратить появление висячих указателей и уязвимостей, связанных с использованием памяти после освобождения. | 2 |

## V1.5 Безопасная десериализация

Преобразование данных из сохраненного или переданного представления в фактические объекты приложения (десериализация) исторически было причиной различных уязвимостей внедрения кода. Важно выполнять этот процесс осторожно и безопасно, чтобы избежать подобных проблем.

В частности, некоторые методы десериализации были определены в документации по языку программирования или фреймворку как небезопасные и не могут безопасно применяться с недоверенными данными. Для каждого используемого механизма следует проводить тщательную проверку.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **1.5.1** | Убедитесь, что приложение настраивает XML-парсеры на использование строгой конфигурации и что небезопасные функции, такие как разрешение внешних сущностей, отключены для предотвращения атак XML eXternal Entity (XXE). | 1 |
| **1.5.2** | Убедитесь, что десериализация недоверенных данных обеспечивает безопасную обработку ввода, например, используя список разрешенных типов объектов или ограничивая типы объектов, определяемые клиентом, для предотвращения атак десериализации. Механизмы десериализации, которые явно определены как небезопасные, не должны использоваться с недоверенным вводом. | 2 |
| **1.5.3** | Убедитесь, что различные парсеры, используемые в приложении для одного и того же типа данных (например, парсеры JSON, XML, URL), выполняют парсинг согласованным образом и используют один и тот же механизм кодирования символов, чтобы избежать таких проблем, как уязвимости взаимодействия JSON (JSON Interoperability) или различное поведение анализа URI или файлов, которые могут использоваться в атаках удаленного включения файлов (RFI) или подделки запросов на стороне сервера (SSRF). | 3 |

## Ссылки

Для дополнительной информации см. также:

* [OWASP LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)
* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)
* [OWASP XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)
* [OWASP Web Security Testing Guide: Client-Side Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing)
* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)
* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)
* [RFC4180 - Common Format and MIME Type for Comma-Separated Values (CSV) Files](https://datatracker.ietf.org/doc/html/rfc4180#section-2)

Для более подробной информации о проблемах сериализации и парсинга см. также:

* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
* [An Exploration of JSON Interoperability Vulnerabilities](https://bishopfox.com/blog/json-interoperability-vulnerabilities)
* [Orange Tsai - A New Era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)
