# V3 Безопасность веб-интерфейса

## Задачи контроля

Эта категория фокусируется на требованиях, направленных на защиту от атак, воспроизводимых через веб-интерфейс. Эти требования не применяются к решениям «машина-машина».

## V3.1 Документация по безопасности веб-интерфейса

В этом разделе описываются функции безопасности браузера, которые должны быть описаны в документации приложения.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **3.1.1** | Убедитесь, что в документации приложения описаны ожидаемые функции безопасности, которые должны поддерживать браузеры, использующие приложение (такие как HTTPS, HTTP Strict Transport Security (HSTS), Content Security Policy (CSP) и другие соответствующие механизмы безопасности HTTP). В документации также должно быть обязательно определено, как приложение должно себя вести, если некоторые из этих функций недоступны (например, предупреждать пользователя или блокировать доступ). | 3 |

## V3.2 Непреднамеренная интерпретация контента

Отображение контента или функциональности в неправильном контексте может привести к выполнению или отображению вредоносного контента.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **3.2.1** | Убедитесь, что реализованы меры безопасности, предотвращающие отображение контента или функций браузерами в HTTP-ответах в некорректном контексте (например, запрос API, загруженный пользователем файл или другой ресурс запрашивается напрямую). Возможные способы контроля включают: не обрабатывать содержимое, если поля заголовка HTTP-запроса (например, Sec-Fetch-*) не указывают на корректность контекста; использование заголовка и значения Content-Security-Policy: sandbox directive; или использование заголовка и значения Content-Disposition: attachment. | 1 |
| **3.2.2** | Убедитесь, что данные, предназначенные для отображения в виде текста, а не визуализации в виде HTML, обрабатывается с использованием безопасных функций визуализации (таких как createTextNode или textContent), чтобы предотвратить непреднамеренное выполнение содержимого, такого как HTML или JavaScript. | 1 |
| **3.2.3** | Убедитесь, что приложение избегает затирания DOM при использовании JavaScript на стороне клиента, применяя явные объявления переменных, выполняя строгую проверку типов, избегая сохранения глобальных переменных в объекте документа и реализуя изоляцию пространства имен. | 3 |

## V3.3 Настройка файлов cookie

В этом разделе изложены требования к безопасной настройке чувствительных cookie, позволяющие обеспечить более высокий уровень уверенности в том, что они были созданы самим приложением, а также предотвратить утечку или ненадлежащее изменение их содержимого.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **3.3.1** | Убедитесь, что у файлов cookie установлен атрибут «Secure», и если префикс «__Host‑» не используется в названии cookie, необходимо использовать префикс «__Secure‑». | 1 |
| **3.3.2** | Убедитесь, что значение атрибута SameSite каждой cookie установлено в соответствии с назначением cookie, чтобы ограничить подверженность атакам на восстановление пользовательского интерфейса и атакам с подделкой запросов на уровне браузера, обычно называемым подделкой межсайтовых запросов (CSRF). | 2 |
| **3.3.3** | Убедитесь, что cookie имеют префикс «__Host‑» в названии, если только они явно не предназначены для совместного использования с другими хостами. | 2 |
| **3.3.4** | Убедитесь, что если значение cookie не должно быть доступно для клиентских скриптов (например, сессионный токен), для cookie должен быть установлен атрибут «HttpOnly», а само значение должно передаваться клиенту только через поле заголовка «Set-Cookie». | 2 |
| **3.3.5** | Убедитесь, что при записи cookie приложением общая длина имени и значения cookie не превышает 4096 байт. Слишком большие cookie не будут сохраняться браузером и, следовательно, не будут отправляться с запросами, что помешает пользователю использовать функции приложения, зависящие от этого cookie. | 3 |

## V3.4 Заголовки механизма безопасности браузера

В этом разделе описывается, какие заголовки безопасности следует устанавливать в HTTP-ответах, чтобы включить функции безопасности браузера и ограничения при обработке ответов от приложения.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **3.4.1** | Убедитесь, что поле заголовка Strict‑Transport‑Security включено во все ответы для реализации политики HTTP Strict Transport Security (HSTS). Необходимо указать максимальное время не менее 1 года, а для L2 и выше политика должна применяться также ко всем поддоменам. | 1 |
| **3.4.2** | Убедитесь, что поле заголовка Cross‑Origin Resource Sharing (CORS) «Access‑Control‑Allow‑Origin» имеет фиксированное значение, заданное приложением, или, если используется заголовок Origin, оно проверяется по списку доверенных источников. При необходимости использования «Access‑Control‑Allow‑Origin: *» убедитесь, что ответ не содержит конфиденциальной информации. | 1 |
| **3.4.3** | Убедитесь, что HTTP-ответы содержат поле заголовка Content-Security-Policy, которое определяет директивы, гарантирующие загрузку и выполнение браузером только доверенного контента или ресурсов, чтобы ограничить выполнение вредоносного JavaScript. Как минимум, необходимо использовать глобальную политику, включающую директивы object-src «none» и base-uri «none», а также определяющую список разрешенных адресов или использующую одноразовые коды или хэши. Для приложений L3 необходимо определить политику использования 'nonce' или hash-конструкций для каждого ответа. | 2 |
| **3.4.4** | Убедитесь, что все HTTP-ответы содержат поле заголовка «X‑Content‑Type‑Options: nosniff». Это предписывает браузерам не использовать анализ контента и определение типа MIME для данного ответа, а также требовать, чтобы значение поля заголовка Content‑Type в ответе соответствовало целевому ресурсу. Например, ответ на запрос стиля принимается только в том случае, если Content‑Type в ответе — «text/css». Это также позволяет браузеру использовать функцию Cross‑Origin Read Blocking (CORB). | 2 |
| **3.4.5** | Убедитесь, что приложение устанавливает политику реферера для предотвращения утечки технически конфиденциальных данных сторонним сервисам через поле заголовка HTTP-запроса «Referer». Это можно сделать с помощью поля заголовка HTTP-ответа «Referrer‑Policy» или через атрибуты HTML-элемента. Конфиденциальные данные могут включать путь и данные запроса в URL-адресе, а для внутренних непубличных приложений также имя хоста. | 2 |
| **3.4.6** | Убедитесь, что веб-приложение использует директиву frame‑ancestors поля заголовка Content‑Security‑Policy для каждого HTTP-ответа, чтобы гарантировать невозможность его внедрения по умолчанию и внедрение определённых ресурсов разрешено только при необходимости. Обратите внимание, что поле заголовка X‑Frame‑Options, хотя и поддерживается браузерами, устарело и не может быть использовано в качестве основы. | 2 |
| **3.4.7** | Убедитесь, что в поле заголовка Content‑Security‑Policy указано место, куда следует сообщать о нарушениях. | 3 |
| **3.4.8** | Убедитесь, что все HTTP-ответы, инициирующие рендеринг документа (например, ответы с типом содержимого text/html), включают поле заголовка Cross-Origin-Opener-Policy с директивой same-origin или same-origin-allow-popups (при необходимости). Это предотвращает атаки, злоупотребляющие общим доступом к объектам Window, такие как Tabnabbing и Frame Counting. | 3 |

## V3.5 Браузерное разделение источников

Принимая запрос к чувствительному функционалу на стороне сервера, приложение должно убедиться, что запрос инициирован самим приложением или доверенной стороной и не был подделан злоумышленником.

К чувствительному функционалу в данном контексте могут относиться принятие форм POST для аутентифицированных и неаутентифицированных пользователей (например, запрос аутентификации), операции по изменению состояния или ресурсоемкие функции (например, экспорт данных).

Ключевыми средствами защиты здесь являются политики безопасности браузера, такие как Same Origin Policy для JavaScript и логика SameSite для cookie. Другим распространённым средством защиты является механизм предварительной проверки CORS. Этот механизм критически важен для конечных точек, спроектированных и предназначенных, чтобы вызываться из другого источника, но он также может быть полезным механизмом предотвращения подделки запросов для конечных точек, которые не предназначены для вызова из другого источника.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **3.5.1** | Убедитесь, что, если приложение не использует механизм предварительной проверки CORS для предотвращения запрещённых кросс-доменных запросов на использование чувствительного функционала, эти запросы валидируются на предмет их происхождения от самого приложения. Это можно сделать, используя и проверяя специальные токены для защиты от подделки или требуя дополнительные поля HTTP-заголовка, не входящие в список «простых заголовков» (CORS-safelisted request-header). Это необходимо для защиты от атак с подделкой запросов через браузер, широко известных как межсайтовая подделка запросов (CSRF). | 1 |
| **3.5.2** | Убедитесь, что если приложение использует механизм предварительной проверки CORS для предотвращения неразрешённого использования чувствительного функционала между источниками, вызов этого функционала невозможен с помощью запроса, который не запускает предварительную проверку CORS. Для этого может потребоваться проверка значений полей заголовка запроса «Origin» и «Content-Type» или использование дополнительного поля заголовка, не входящего в безопасный список CORS. | 1 |
| **3.5.3** | Убедитесь, что HTTP-запросы к чувствительному функционалу используют соответствующие HTTP-методы, такие как POST, PUT, PATCH или DELETE, а не методы, определённые спецификацией HTTP как «безопасные», такие как HEAD, OPTIONS или GET. В качестве альтернативы можно использовать строгую валидацию полей заголовка запроса Sec‑Fetch‑*, чтобы убедиться, что запрос не исходит из недопустимого кросс-доменного вызова, навигационного запроса или загрузки ресурса (например, источника изображения), где это не ожидается. | 1 |
| **3.5.4** | Убедитесь, что отдельные приложения размещены на разных именах хостов, чтобы использовать ограничения, предусмотренные политикой same-origin, включая то, как документы или скрипты, загруженные одним источником, могут взаимодействовать с ресурсами из другого источника, а также ограничения на cookie на основе имени хоста. | 2 |
| **3.5.5** | Убедитесь, что сообщения, полученные интерфейсом postMessage, отвергаются, если источник сообщения не является доверенным или если синтаксис сообщения недействителен. | 2 |
| **3.5.6** | Убедитесь, что функциональность JSONP не включена нигде в приложении, чтобы избежать атак с использованием межсайтового включения скриптов (XSSI). | 3 |
| **3.5.7** | Убедитесь, что данные, требующие авторизации, не включены в ответы ресурсов скриптов, таких как файлы JavaScript, чтобы предотвратить атаки с использованием межсайтового включения скриптов (XSSI). | 3 |
| **3.5.8** | Убедитесь, что аутентифицированные ресурсы (такие как изображения, видео, скрипты и другие документы) могут быть загружены или внедрены от имени пользователя только по назначению. Этого можно добиться путём строгой валидации полей заголовка HTTP-запроса Sec‑Fetch‑*, чтобы убедиться, что запрос не исходит из недопустимого кросс-доменного вызова, или путём установки ограничительного поля заголовка HTTP-ответа Cross‑Origin‑Resource‑Policy, чтобы браузер блокировал возвращаемый контент. | 3 |

## V3.6 Целостность внешних ресурсов

В этом разделе приведены рекомендации по безопасному размещению контента на сторонних сайтах.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **3.6.1** | Убедитесь, что клиентские ресурсы, такие как библиотеки JavaScript, CSS или веб-шрифты, размещаются только на внешнем сервере (например, в сети доставки контента (Content Delivery Network)), если ресурс статический и имеет версии, а для проверки целостности ресурса используется механизм проверки целостности подресурсов (SRI). Если это невозможно, для каждого ресурса должно быть задокументировано решение по безопасности, обосновывающее это. | 3 |

## V3.7 Другие соображения по безопасности браузера

В этом разделе рассматриваются различные другие элементы управления безопасностью и современные функции безопасности браузера, необходимые для обеспечения безопасности браузера на стороне клиента.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **3.7.1** | Убедитесь, что приложение использует только те клиентские технологии, которые по-прежнему поддерживаются и считаются безопасными. Примерами технологий, не соответствующих этому требованию, являются плагины NSAPI, Flash, Shockwave, ActiveX, Silverlight, NACL или клиентские Java-апплеты. | 2 |
| **3.7.2** | Убедитесь, что приложение будет автоматически перенаправлять пользователя на другое имя хоста или домен (который не контролируется приложением), только если этот хост или домен указаны в списке разрешенных. | 2 |
| **3.7.3** | Убедитесь, что приложение отображает уведомление, что пользователь перенаправляется на URL-адрес, находящийся вне контроля приложения, с возможностью отмены навигации. | 3 |
| **3.7.4** | Убедитесь, что домен верхнего уровня приложения (например, site.tld) ​​добавлен в публичный список предварительной загрузки (preload list) для HTTP Strict Transport Security (HSTS). Это гарантирует, что использование TLS для приложения будет встроено непосредственно в основные браузеры, а не будет полагаться только на поле заголовка ответа Strict-Transport-Security. | 3 |
| **3.7.5** | Убедитесь, что приложение ведет себя так, как описано в документации (например, предупреждает пользователя или блокирует доступ), если браузер, используемый для доступа к приложению, не поддерживает ожидаемые функции безопасности. | 3 |

## Ссылки

Для дополнительной информации см. также:

* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#cookie_prefixes)
* [OWASP Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)
* [OWASP Secure Headers Project](https://owasp.org/www-project-secure-headers/)
* [OWASP Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
* [HSTS Browser Preload List submission form](https://hstspreload.org/)
* [OWASP DOM Clobbering Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_Clobbering_Prevention_Cheat_Sheet.html)
