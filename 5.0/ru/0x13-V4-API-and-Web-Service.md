# V4 API и Веб-сервис

## Задачи контроля

Существует несколько моментов, применимых только к приложениям, предоставляющим API для использования веб-браузерами или другими клиентами (обычно с использованием JSON, XML или GraphQL). В этой главе рассматриваются соответствующие настройки и механизмы безопасности, которые следует применять.

Обратите внимание, что вопросы аутентификации, управления сессиями и проверки входных данных, рассмотренные в других главах, также относятся к API. Поэтому эту главу нельзя рассматривать изолированно или тестировать отдельно.

## V4.1 Общая безопасность веб-сервисов

В этом разделе рассматриваются общие вопросы безопасности веб-сервисов и базовые практики гигиены веб-сервисов.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **4.1.1** | Убедитесь, что каждый HTTP-ответ с телом сообщения содержит заголовок Content-Type, который соответствует фактическому содержимому ответа, таким как «text/», «/+xml» и «/xml», включая параметр charset для указания безопасной кодировки символов (например, UTF-8, ISO-8859-1) согласно IANA Media Types. | 1 |
| **4.1.2** | Убедитесь, что только конечные точки, предназначенные для взаимодействия с пользователем через веб-браузер, автоматически перенаправляют HTTP на HTTPS, в то время как другие сервисы или конечные точки не реализуют прозрачные редиректы. Это необходимо, чтобы избежать ситуации, когда клиент ошибочно отправляет незашифрованные HTTP-запросы а из-за того, что запрос по HTTP автоматически перенаправляется на HTTPS другим сервисом без обработки на входе, утечка чувствительных данных остаётся незамеченной. | 2 |
| **4.1.3** | Убедитесь, что любой HTTP-заголовок, используемый приложением и устанавливаемый промежуточным уровнем, таким как балансировщик нагрузки, веб-прокси или backend-for-frontend сервис, не может быть переопределён конечным пользователем. Примеры заголовков: X-Real-IP, X-Forwarded-*, X-User-ID. | 2 |
| **4.1.4** | Убедитесь, что разрешены только HTTP-методы, которые явно поддерживаются приложением или его API (включая OPTIONS для preflight-запросов), а неиспользуемые методы заблокированы. | 3 |
| **4.1.5** | Убедитесь, что для особо чувствительных запросов или транзакций, проходящих через несколько систем, используются цифровые подписи на уровне сообщений, дополнительно к транспортным средствам защиты. | 3 |

## V4.2 Валидация структуры HTTP-сообщений

Этот раздел объясняет, как должна проверяться структура и заголовки HTTP-сообщений, чтобы предотвратить атаки типа request smuggling, response splitting, header injection и отказ в обслуживании из-за слишком длинных HTTP-сообщений.

Эти требования актуальны для обработки и генерации HTTP-сообщений в целом, но особенно важны при конвертации сообщений между разными версиями HTTP.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **4.2.1** | Убедитесь, что все компоненты приложения (включая балансировщики нагрузки, файрволы и серверы приложений) определяют границы входящих HTTP-сообщений с использованием механизма, соответствующего версии HTTP, чтобы предотвратить HTTP request smuggling. В HTTP/1.x, если присутствует заголовок Transfer-Encoding, заголовок Content-Length должен игнорироваться согласно RFC 2616. При использовании HTTP/2 или HTTP/3, если присутствует Content-Length, веб-сервер должен убедиться, что он совпадает с длиной DATA-фреймов. | 2 |
| **4.2.2** | Убедитесь, что при генерации HTTP-сообщений заголовок Content-Length не конфликтует с длиной содержимого, определяемой рамками протокола HTTP, чтобы предотвратить HTTP Request Smuggling. | 3 |
| **4.2.3** | Убедитесь, что приложение не отправляет и не принимает HTTP/2 и HTTP/3 сообщения с заголовками, специфичными для соединения, такими как Transfer-Encoding, чтобы предотвратить HTTP Response Splitting и HTTP Header Injection. | 3 |
| **4.2.4** | Убедитесь, что приложение принимает HTTP/2 и HTTP/3 запросы только в случае, если поля заголовков и их значения не содержат последовательностей CR (\r), LF (\n) или CRLF (\r\n), чтобы предотвратить HTTP Header Injection. | 3 |
| **4.2.5** | Убедитесь, что если приложение (бекенд или фронтенд) формирует и отправляет запросы, оно использует валидацию, очистку или другие механизмы, чтобы не создавать URI (например, для API-вызовов) или HTTP-заголовки (например, Authorization или Cookie) слишком большой длины, чтобы их не принимал приёмник. Это может привести к отказу в обслуживании, например, при отправке слишком длинного запроса (длинный cookie-заголовок), из-за чего сервер постоянно возвращает ошибку. | 3 |

## V4.3 GraphQL

GraphQL становится всё более популярным способом создания клиентов с большим объёмом данных, которые не жёстко связаны с разными бэкенд-сервисами. В этом разделе рассмотрены вопросы безопасности для GraphQL.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **4.3.1** | Убедитесь, что используется белый список запросов, ограничение глубины вложенности, ограничение количества или анализ стоимости запроса, чтобы предотвратить DoS-атаки на уровне GraphQL или слоя данных из-за дорогостоящих вложенных запросов. | 2 |
| **4.3.2** | Убедитесь, что introspection-запросы GraphQL отключены в продакшен-среде, если GraphQL API не предназначен для использования сторонними клиентами. | 2 |

## V4.4 WebSocket

WebSocket — это протокол связи, обеспечивающий двунаправленную одновременную коммуникацию по одному TCP-соединению. Он был стандартизирован IETF в RFC 6455 в 2011 году и отличается от HTTP, хотя и работает поверх портов HTTP 443 и 80.

В этом разделе приведены основные требования по безопасности, чтобы предотвратить атаки, связанные с безопасностью коммуникаций и управлением сессиями, которые эксплуатируют этот канал реального времени.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **4.4.1** | Убедитесь, что для всех WebSocket-соединений используется WebSocket поверх TLS (WSS). | 1 |
| **4.4.2** | Убедитесь, что при первоначальном HTTP WebSocket handshake заголовок Origin проверяется на соответствие списку разрешённых источников для приложения. | 2 |
| **4.4.3** | Убедитесь, что если стандартное управление сессиями приложения не может быть использовано, применяются специальные токены, соответствующие требованиям безопасности управления сессиями. | 2 |
| **4.4.4** | Убедитесь, что специальные токены управления сессиями WebSocket изначально получаются или валидируются через ранее аутентифицированную HTTPS-сессию при переходе от HTTPS к WebSocket. | 2 |

## Ссылки

Для дополнительной информации см. также:

* [OWASP REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)
* Ресурсы по авторизации GraphQL от [graphql.org](https://graphql.org/learn/authorization/) и [Apollo](https://www.apollographql.com/docs/apollo-server/security/authentication/#authorization-methods).
* [OWASP Web Security Testing Guide: GraphQL Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/12-API_Testing/01-Testing_GraphQL)
* [OWASP Web Security Testing Guide: Testing WebSockets](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing/10-Testing_WebSockets)
