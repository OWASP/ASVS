# V10 OAuth и OIDC

## Задачи контроля

OAuth2 (в этой главе именуется просто OAuth) — это общепринятый отраслевой стандарт делегированной авторизации. Например, с помощью OAuth клиентское приложение может получить доступ к API (ресурсам сервера) от имени пользователя, если тот дал на это разрешение.

Сама по себе технология OAuth не предназначена для аутентификации пользователей. Фреймворк OpenID Connect (OIDC) расширяет OAuth, добавляя слой идентификации пользователя. OIDC поддерживает такие функции, как стандартизированная информация о пользователе, единый вход (SSO) и управление сессиями. Поскольку OIDC является надстройкой над OAuth, все требования, предъявляемые к OAuth, также применимы к OIDC.

В OAuth определены следующие роли:

* OAuth-клиент — приложение, пытающееся получить доступ к серверным ресурсам (например, через вызов API с использованием access token). Чаще всего это серверное приложение.
    * Конфиденциальный клиент (confidential client) — клиент, способный сохранять в тайне свои учетные данные (например, client_secret) для аутентификации на авторизационном сервере.
    * Публичный клиент (public client) — клиент, неспособный хранить учетные данные в секрете. Вместо аутентификации (например, с использованием пары client_id и client_secret) он лишь идентифицирует себя через client_id.
* OAuth-ресурсный сервер (Resource Server, RS) — сервер API, предоставляющий ресурсы клиентам OAuth.
* OAuth-авторизационный сервер (Authorization Server, AS) — сервер, выдающий клиентам access token'ы. Эти токены позволяют клиенту получать доступ к ресурсам RS — либо от имени пользователя, либо от имени самого клиента. Часто AS — это отдельное приложение, но при необходимости может быть интегрирован в RS.
* Владелец ресурса (Resource Owner, RO) — конечный пользователь, разрешающий OAuth-клиенту ограниченный доступ к своим данным на RS. Пользователь предоставляет это разрешение через взаимодействие с AS.

В OIDC определены следующие роли:

* Relying Party (RP) — клиентское приложение, запрашивающее аутентификацию пользователя через OpenID-провайдера. В терминах OAuth оно также является OAuth-клиентом.
* OpenID-провайдер (OP) — авторизационный сервер OAuth, способный аутентифицировать пользователя и предоставлять RP claims в рамках OIDC. OP может быть IdP (провайдером идентификации), но в федеративных сценариях OP и IdP могут быть разными приложениями.

Изначально OAuth и OIDC были разработаны для сторонних приложений. Однако в настоящее время они часто используются и в first-party сценариях. Например, для аутентификации и управления сессиями. В таких случаях протоколы добавляют некоторую сложность, которая может привести к новым проблемам с безопасностью.

OAuth и OIDC могут использоваться в различных типах приложений, однако в OWASP ASVS акцент делается на веб-приложения и API.

Поскольку OAuth и OIDC работают поверх веб-технологий, на них распространяются общие требования из других глав. Этот раздел не следует рассматривать изолированно.

В этой главе рассматриваются лучшие современные практики OAuth2 и OIDC в ​​соответствии со спецификациями, представленными на <https://oauth.net/2/> и <https://openid.net/developers/specs/>. Поскольку RFC часто обновляются, при применении требований, изложенных в этой главе, следует сверяться с их последними версиями. Подробнее см. в разделе «Ссылки».

С учетом сложности темы крайне важно использовать проверенные стандартные решения (например, авторизационные серверы от крупных вендоров) и применять рекомендованные параметры безопасности.

Терминология в этой главе соответствует RFC OAuth и спецификациям OIDC. Однако OIDC-термины используются только в OIDC-специфичных требованиях. В остальных случаях применяется терминология OAuth.

В этом разделе под «токеном» понимается:

* Access Token используется только ресурсным сервером (RS). Может быть:
    * ссылочным (reference token), проверяется через introspection.
    * автономным (self-contained), проверяется через криптографически подписанный материал.
* Refresh Token используется только авторизационным сервером, выдавшим токен.
* OIDC ID Token используется только клиентским приложением, инициировавшим процесс авторизации.

Уровни риска для некоторых требований зависят от того, является ли клиент конфиденциальным или публичным. Поскольку сильная клиентская аутентификация снижает многие риски, в случае конфиденциальных клиентов на уровне L1 возможны послабления.

## V10.1 Общие требования безопасности OAuth и OIDC

В этом разделе изложены универсальные архитектурные требования, применимые ко всем приложениям, использующим OAuth или OIDC.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **10.1.1** | Убедитесь, что токены передаются только тем компонентам, которым они действительно необходимы. Например, при использовании схемы backend-for-frontend для браузерных JavaScript-приложений, access и refresh токены должны быть доступны только на backend. | 2 |
| **10.1.2** | Убедитесь, что клиент принимает значения от авторизационного сервера (например, authorization code или ID Token) только если они получены в результате авторизационного потока, инициированного в той же сессии пользовательского агента и в рамках той же транзакции. Для этого клиентские секреты, такие как proof key для code exchange (PKCE) — 'code_verifier', 'state' или OIDC 'nonce' — должны быть непредсказуемыми, специфичными для транзакции и надежно привязанными как к клиенту, так и к сессии пользовательского агента, в которой началась транзакция. | 2 |

## V10.2 Клиент OAuth

Данные требования описывают обязанности приложений-клиентов OAuth. Клиентом может быть, например, backend веб-сервера (часто выступающий как Backend For Frontend, BFF), интеграция backend-сервиса или frontend-приложение одностраничного типа (SPA, то есть браузерное приложение).

В общем случае backend-клиенты считаются конфиденциальными (confidential clients), а frontend — публичными (public clients). Однако нативные приложения, работающие на устройстве конечного пользователя, могут рассматриваться как конфиденциальные при использовании динамической регистрации OAuth клиента.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **10.2.1** | Убедитесь, что если используется механизм authorization code flow, OAuth клиент защищён от CSRF, вызывающих запросы токенов либо за счёт использования механизма proof key for code exchange (PKCE), либо за счёт проверки параметра 'state', который был отправлен в запросе авторизации. | 2 |
| **10.2.2** | Убедитесь, что если OAuth клиент может взаимодействовать с более чем одним сервером авторизации, у него есть защита от атак смешивания (mix-up attacks). Например, клиент должен требовать, чтобы сервер авторизации возвращал параметр 'iss' и проверять его в ответах на авторизацию и токены. | 2 |
| **10.2.3** | Убедитесь, что OAuth клиент запрашивает только необходимые области доступа (scopes) или другие параметры авторизации в запросах к серверу авторизации. | 3 |

## V10.3 Сервер ресурсов OAuth

В контексте ASVS и данного раздела сервер ресурсов — это API. Для обеспечения безопасного доступа сервер ресурсов должен:

* Валидировать access token в соответствии с форматом токена и спецификациями протокола, например, валидация JWT или интроспекция OAuth токена.
* Если токен действителен, принимать решения по авторизации на основе информации из токена и предоставленных разрешений. Например, сервер ресурсов должен проверить, что клиент (действующий от имени владельца ресурса) имеет право доступа к запрошенному ресурсу.

Таким образом, требования здесь специфичны для OAuth или OIDC и должны выполняться после валидации токена и перед принятием решения об авторизации на основе информации из токена.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **10.3.1** | Убедитесь, что сервер ресурсов принимает только те access токены, которые предназначены для использования с этим сервисом (свойство audience). Эта принадлежность сервису может быть включена в структурированный access токен (например, в поле 'aud' в JWT) или проверяться через endpoint интроспекции токена. | 2 |
| **10.3.2** | Убедитесь, что сервер ресурсов принимает решения по авторизации на основе claims из access токена, определяющих делегированную авторизацию. Если присутствуют claims, такие как 'sub', 'scope' и 'authorization_details', они должны участвовать в принятии решения. | 2 |
| **10.3.3** | Убедитесь, что если для принятия решения по контролю доступа необходимо однозначно идентифицировать пользователя из access токена (JWT или ответа интроспекции), сервер ресурсов использует claims, которые не могут быть переприсвоены другим пользователям. Обычно это комбинация claims 'iss' и 'sub'. | 2 |
| **10.3.4** | Убедитесь, что если сервер ресурсов требует определённой силы аутентификации, методов или свежести аутентификации, он проверяет, что предъявленный access токен удовлетворяет этим требованиям. Например, при наличии, могут использоваться claims OIDC 'acr', 'amr' и 'auth_time'. | 2 |
| **10.3.5** | Убедитесь, что сервер ресурсов предотвращает использование украденных access токенов или их повторное использование (replay) неавторизованными лицами, требуя access токены с подтверждением отправителя — например, Mutual TLS для OAuth 2 или OAuth 2 Demonstration of Proof of Possession (DPoP). | 3 |

## V10.4 Сервер авторизации OAuth

Эти требования описывают обязанности серверов авторизации OAuth, включая OpenID провайдеров.

Для аутентификации клиента разрешён метод 'self_signed_tls_client_auth' при выполнении предварительных требований, указанных в [разделе 2.2](https://datatracker.ietf.org/doc/html/rfc8705#name-self-signed-certificate-mut) стандарта [RFC 8705](https://datatracker.ietf.org/doc/html/rfc8705).

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **10.4.1** | Убедитесь, что сервер авторизации проверяет URI перенаправления (redirect URI), сверяя его с заранее зарегистрированным списком разрешённых URI для данного клиента (allowlist), используя точное сравнение строк. | 1 |
| **10.4.2** | Убедитесь, что если сервер авторизации возвращает authorization code в ответе авторизации, этот код может быть использован только один раз для запроса токена. При втором валидном запросе с уже использованным кодом сервер должен отклонить запрос и отозвать любые токены, связанные с этим кодом. | 1 |
| **10.4.3** | Убедитесь, что authorization code имеет короткое время жизни. Максимальная продолжительность — до 10 минут для приложений L1 и L2 и до 1 минуты для приложений L3. | 1 |
| **10.4.4** | Убедитесь, что сервер авторизации для конкретного клиента разрешает использование только тех типов авторизации, которые необходимы этому клиенту. Обратите внимание, что тип авторизации Implicit flow и Resource Owner Password Credentials flow больше не должны использоваться. | 1 |
| **10.4.5** | Убедитесь, что сервер авторизации предотвращает атаки повторного использования refresh токенов для публичных клиентов, предпочтительно используя sender-constrained refresh токены, такие как DPoP или сертификат-связанные токены с mutual TLS (mTLS). Для L1 и L2 допускается ротация refresh токенов с обязательной их инвалидацией после использования. Если используется ротация, сервер должен отозвать все refresh токены при попытке использовать уже инвалидированный токен. | 1 |
| **10.4.6** | Убедитесь, что при использовании типа авторизации «Authorization Code» сервер предотвращает атаки перехвата authorization code, требуя Proof Key for Code Exchange (PKCE). В запросах авторизации сервер должен требовать валидное значение 'code_challenge' и не принимать 'code_challenge_method' со значением 'plain'. В запросах токена обязательно валидировать параметр 'code_verifier'. | 2 |
| **10.4.7** | Убедитесь, что если сервер авторизации поддерживает динамическую регистрацию клиентов без аутентификации, он минимизирует риски вредоносных клиентов. Сервер должен валидировать метаданные клиента (например, зарегистрированные URI), обеспечивать согласие пользователя и предупреждать пользователя перед обработкой запроса авторизации от недоверенного клиента. | 2 |
| **10.4.8** | Убедитесь, что refresh токены имеют абсолютный срок действия, включая случаи, когда применяется скользящее время истечения срока. | 2 |
| **10.4.9** | Убедитесь, что пользователи могут отзывать refresh токены и reference access токены через пользовательский интерфейс сервера авторизации для снижения риска от вредоносных клиентов или кражи токенов. | 2 |
| **10.4.10** | Убедитесь, что конфиденциальный клиент аутентифицируется при взаимодействии с сервером авторизации через backchannel, например при запросах токена, pushed authorization requests (PAR) и запросах на отзыв токенов. | 2 |
| **10.4.11** | Убедитесь, что конфигурация сервера авторизации назначает OAuth клиенту только необходимые области доступа (scopes). | 2 |
| **10.4.12** | Убедитесь, что для конкретного клиента сервер авторизации разрешает только те значения 'response_mode', которые необходимы этому клиенту. Например, сервер должен валидировать это значение против ожидаемых или использовать pushed authorization request (PAR) или JWT-secured Authorization Request (JAR). | 3 |
| **10.4.13** | Убедитесь, что грант типа 'code' всегда используется вместе с pushed authorization requests (PAR). | 3 |
| **10.4.14** | Убедитесь, что сервер авторизации выдаёт только sender-constrained (Proof-of-Possession) access токены, либо с сертификат-связанными токенами через mutual TLS (mTLS), либо DPoP-bound токены (Demonstration of Proof of Possession). | 3 |
| **10.4.15** | Убедитесь, что для серверного клиента (не выполняющегося на устройстве конечного пользователя) сервер авторизации проверяет, что значение параметра 'authorization_details' исходит из клиентского backend и что пользователь не изменял его. Например, это достигается использованием pushed authorization request (PAR) или JWT-secured Authorization Request (JAR). | 3 |
| **10.4.16** | Убедитесь, что клиент является конфиденциальным и сервер авторизации требует использования сильных методов аутентификации клиента (основанных на криптографии с открытым ключом и устойчивых к атакам повторного воспроизведения), таких как mutual TLS ('tls_client_auth', 'self_signed_tls_client_auth') или private key JWT ('private_key_jwt'). | 3 |

## V10.5 Клиент OIDC

Поскольку OIDC клиент (relying party) выступает в роли OAuth клиента, на него также распространяются требования из раздела «OAuth Client».

Обратите внимание, что в разделе «Аутентификация с использованием провайдера идентификаций (IdP)» главы «Аутентификация» содержатся дополнительные общие требования.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **10.5.1** | Убедитесь, что клиент (relying party) защищается от повторного использования ID Token (replay-атак). Например, это достигается проверкой того, что значение 'nonce' в ID Token совпадает со значением 'nonce', отправленным в запросе аутентификации провайдеру OpenID (authorization server). | 2 |
| **10.5.2** | Убедитесь, что клиент однозначно идентифицирует пользователя по утверждениям (claims) ID Token, обычно это 'sub', который не может быть переназначен другому пользователю (в пределах конкретного провайдера идентификации). | 2 |
| **10.5.3** | Убедитесь, что клиент отклоняет попытки злоумышленного сервера авторизации выдавать себя за другой сервер авторизации через метаданные сервера авторизации. Клиент должен отклонить метаданные, если URL издателя (issuer) в метаданных не совпадает точно с преднастроенным URL издателя, ожидаемым клиентом. | 2 |
| **10.5.4** | Убедитесь, что клиент проверяет, что ID Token предназначен для него (проверка audience), сравнивая значение 'aud' в токене с 'client_id' клиента. | 2 |
| **10.5.5** | Убедитесь, что при использовании OIDC back-channel logout клиент снижает риск отказа в обслуживании, вызванный принудительным выходом из системы и путаницей между разными типами JWT (cross-JWT confusion) в процессе логаута. Клиент должен проверить, что токен выхода корректно типизирован со значением 'logout+jwt', содержит claim 'event' с правильным именем участника и не содержит 'nonce'. Также рекомендуется установить короткий срок действия токена (например, 2 минуты). | 2 |

## V10.6 Провайдер OpenID

Поскольку провайдеры OpenID выступают в роли OAuth серверов авторизации, на них также распространяются требования из раздела «Сервер авторизации OAuth».

Обратите внимание, что при использовании потока ID Token (а не code flow) access токены не выдаются, и многие требования к OAuth AS в этом случае неприменимы.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **10.6.1** | Убедитесь, что провайдер OpenID допускает только значения 'code', 'ciba', 'id_token' или 'id_token code' для параметра response mode. При этом предпочтение отдаётся 'code' по сравнению с 'id_token code' (гибридный поток OIDC), а значение 'token' (любой Implicit flow) не должно использоваться. | 2 |
| **10.6.2** | Убедитесь, что провайдер OpenID предотвращает отказ в обслуживании (DoS) через принудительный выход (logout), запрашивая явное подтверждение от конечного пользователя или, если применимо, проверяя параметры в запросе выхода (инициированном relying party), например параметр 'id_token_hint'. | 2 |

## V10.7 Управление согласием

Эти требования касаются проверки согласия пользователя авторизационным сервером. Без правильной проверки согласия пользователя злоумышленник может получить разрешения от имени пользователя с помощью подделки или социальной инженерии.

| # | Описание | Уровень |
| :---: | :--- | :---: |
| **10.7.1** | Убедитесь, что авторизационный сервер обеспечивает получение согласия пользователя для каждого запроса авторизации. Если личность клиента не может быть подтверждена, сервер авторизации всегда должен явно запрашивать согласие пользователя. | 2 |
| **10.7.2** | Убедитесь, что при запросе согласия пользователя авторизационный сервер предоставляет достаточную и понятную информацию о том, на что даётся согласие. При необходимости это должно включать характер запрашиваемых разрешений (обычно основанных на scope, ресурсном сервере, деталях авторизации Rich Authorization Requests (RAR)), идентификацию авторизованного приложения и срок действия этих разрешений. | 2 |
| **10.7.3** | Убедитесь, что пользователь может просматривать, изменять и отзывать согласия, которые он предоставил, через авторизационный сервер. | 2 |

## Ссылки

Для дополнительной информации об OAuth см.:

* [oauth.net](https://oauth.net/)
* [OWASP OAuth 2.0 Protocol Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OAuth2_Cheat_Sheet.html)

Для требований, связанных с OAuth, в ASVS используются следующие опубликованные и находящиеся в статусе черновика RFC:

* [RFC6749 The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)
* [RFC6750 The OAuth 2.0 Authorization Framework: Bearer Token Usage](https://datatracker.ietf.org/doc/html/rfc6750)
* [RFC6819 OAuth 2.0 Threat Model and Security Considerations](https://datatracker.ietf.org/doc/html/rfc6819)
* [RFC7636 Proof Key for Code Exchange by OAuth Public Clients](https://datatracker.ietf.org/doc/html/rfc7636)
* [RFC7591 OAuth 2.0 Dynamic Client Registration Protocol](https://datatracker.ietf.org/doc/html/rfc7591)
* [RFC8628 OAuth 2.0 Device Authorization Grant](https://datatracker.ietf.org/doc/html/rfc8628)
* [RFC8707 Resource Indicators for OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707)
* [RFC9068 JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens](https://datatracker.ietf.org/doc/html/rfc9068)
* [RFC9126 OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/html/rfc9126)
* [RFC9207 OAuth 2.0 Authorization Server Issuer Identification](https://datatracker.ietf.org/doc/html/rfc9207)
* [RFC9396 OAuth 2.0 Rich Authorization Requests](https://datatracker.ietf.org/doc/html/rfc9396)
* [RFC9449 OAuth 2.0 Demonstrating Proof of Possession (DPoP)](https://datatracker.ietf.org/doc/html/rfc9449)
* [RFC9700 Best Current Practice for OAuth 2.0 Security](https://datatracker.ietf.org/doc/html/rfc9700)
* [draft OAuth 2.0 for Browser-Based Applications](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps)<!-- recheck on release -->
* [draft The OAuth 2.1 Authorization Framework](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12)<!-- recheck on release -->

Для получения дополнительной информации об OpenID Connect см.:

* [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
* [FAPI 2.0 Security Profile](https://openid.net/specs/fapi-security-profile-2_0-final.html)
