# V11 암호화

## 제어 목표

본 장의 목표는 암호화의 일반적인 사용에 대한 모범 사례를 정의하고, 암호화 원리에 대한 근본적인 이해를 확립하여 더욱 견고하고 현대적인 접근 방식으로 전환하도록 장려하는 것이다. 본 장에서는 다음을 권장한다.

* 안전하게 실패하고, 진화하는 위협에 적응하며, 미래에도 사용할 수 있는 강력한 암호화 시스템을 구현한다.
* 안전하고 업계 모범 사례에 부합하는 암호화 메커니즘을 활용한다.
* 적절한 접근 제어 및 감사 기능을 갖춘 안전한 암호화 키 관리 시스템을 유지한다.
* 새로운 위험을 평가하고 그에 따라 알고리즘을 조정하기 위해 암호화 환경을 정기적으로 평가한다.
* 애플리케이션의 수명 주기 동안 모든 암호화 자산을 식별하고 보호하기 위해 암호화 사용 사례를 지속적으로 발견하고 관리해야 한다.

이 문서는 일반적인 원칙 및 모범 사례를 설명하는 것 외에도, '부록 C - 암호화 표준의 요구 사항'에 대한 보다 심층적인 기술 정보를 제공한다. 여기에는 이 장의 요구 사항 목적에 따라 "승인된" 것으로 간주되는 알고리즘 및 모드가 포함되어 있다.

비밀 관리 또는 통신 보안과 같이 별도의 문제를 해결하기 위해 암호화를 사용하는 요구 사항은 본 표준의 다른 장에서 기술될 것이다.

## V11.1 암호화 인벤토리 및 문서화

애플리케이션은 데이터 자산의 분류에 따라 이를 보호하기 위한 강력한 암호화 아키텍처로 설계되어야 한다. 모든 데이터를 암호화하는 것은 낭비이며, 아무것도 암호화하지 않는 것은 법적 책임을 초래할 수 있다. 암호화는 일반적으로 아키텍처 설계 또는 상위 수준 설계, 설계 스프린트(design sprint) 또는 아키텍처 스파이크(architecture spike) 단계에서 균형 있게 적용되어야 한다. 즉흥적으로 암호화를 설계하거나 사후에 적용하는 것은 초기부터 구축하는 것보다 안전하게 구현하는 데 훨씬 더 많은 비용이 발생하게 된다.

모든 암호화 자산을 정기적으로 식별, 목록화 및 평가하는 것이 중요하다. 수행 방법에 대한 자세한 내용은 부록을 참조할 수 있다..

양자 컴퓨팅의 등장을 대비하여 암호화 시스템의 미래 안정성(future-proofing)을 확보하는 것 또한 매우 중요하다. 양자 내성 암호(Post-Quantum Cryptography; PQC)는 양자 컴퓨팅에 의해 RSA 및 타원 곡선 암호(Elliptic Curve Cryptography; ECC)와 같이 널리 사용되는 알고리즘을 무력화될 것으로 예상됨에 따라 필수적으로 고려되어야 한다.

검증된 PQC 기본 요소 및 표준에 대한 현재 지침은 부록을 참조해야 한다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **11.1.1** | 'NIST SP 800-57'과 같은 암호화 키 관리 및 키 관리 표준을 따르는 암호화 키 수명 주기에 대한 문서화 된 정책이 있는지 검증해야 한다. 여기에는 키가 과도하게 공유되지 않도록 하는 것이 포함된다(예: 공유 비밀의 경우 두 개를 초과하는 엔터티와 공유 및 개인 키의 경우 한 개를 초과하는 엔터티에 공유). | 2 |
| **11.1.2** | 애플리케이션에서 사용되는 모든 암호화 키, 알고리즘, 인증서를 포함한 암호화 자산 목록(cryptographic inventory)이 작성되고, 유지되며, 정기적으로 업데이트되고 있는지 검증해야 한다. 또한, 각 키가 시스템 내에서 사용 가능한 위치와 사용이 제한되는 위치, 해당 키로 보호할 수 있는 데이터 유형과 보호할 수 없는 데이터 유형이 문서화되어 있어야 한다. | 2 |
| **11.1.3** | 암호화, 해싱, 서명 작업을 포함하는 시스템 내의 모든 암호화 사용 사례를 식별하기 위해, 암호화 사용 탐지 메커니즘이 적용되는지 검증해야 한다. | 3 |
| **11.1.4** | 암호화 자산 목록이 유지 관리되는지 검증해야 한다. 여기에는 미래의 위협에 대응하기 위해 양자 내성 암호(Post-Quantum Cryptography; PQC)와 같은 새로운 암호화 표준으로의 마이그레이션 계획을 설명하는 문서화된 계획이 포함되어야 한다. | 3 |

## V11.2 안전한 암호화 구현

이 섹션은 애플리케이션의 핵심 암호화 알고리즘 선택, 구현 및 지속적인 관리에 대한 요구 사항을 정의한다. 목표는 현재 표준(예: NIST, ISO/IEC) 및 모범 사례에 맞춰 강력하고 업계에서 인정하는 암호화 기본 요소만 배포되도록 하는 것이다. 조직은 각 암호화 구성 요소가 동료 검토(peer-review)를 거친 증거와 실제 보안 테스트를 기반으로 선택되도록 해야 한다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **11.2.1** | 암호화 작업에 업계에서 검증된 구현(라이브러리 및 하드웨어 가속 구현 포함)이 사용되는지 검증해야 한다. | 2 |
| **11.2.2** | 난수, 인증 암호화, MAC, 해싱 알고리즘, 키 길이, 라운드, 암호 및 모드를 언제든지 재구성, 업그레이드 또는 교체하여 암호화 해독으로부터 보호할 수 있도록 애플리케이션이 암호화 유연성(crypto agility)을 갖추고 설계되었는지 검증해야 한다. 또한, 키와 비밀번호를 교체하고 데이터를 다시 암호화하는 것도 가능해야 한다. 이를 통해 승인된 PQC 체계(또는 표준)의 고신뢰 구현이 널리 사용 가능해지면 PQC로 원활하게 업그레이드할 수 있다. | 2 |
| **11.2.3** | 모든 암호화 기본 구성요소(primitive)가 알고리즘, 키 크기 및 구성에 따라 최소 128비트의 보안강도를 제공하는지 검증해야 한다. 예를 들어, 256비트 ECC 키는 대략 128비트의 보안을 제공하며, RSA는 128비트의 보안을 달성하기 위해 3072비트 키를 필요로 한다. | 2 |
| **11.2.4** | 민감한 정보가 누출되는 것을 방지하기 위해 모든 암호화 연산은 상수 시간(constant-time)으로 수행되어야 하며, 비교, 계산, 반환 과정에서 단락(short-circuit) 연산이 없는지 검증해야 한다. | 3 |
| **11.2.5** | 모든 암호화 모듈이 안전하게 실패하고, 패딩 오라클 공격(Padding Oracle attacks)과 같은 취약점을 허용하지 않는 방식으로 오류가 처리되는지 검증해야 한다. | 3 |

## V11.3 암호화 알고리즘

AES 및 CHACHA20을 기반으로 구축된 인증 암호화 알고리즘은 현대 암호화 관행의 근간을 이룬다.

| # | 설명 | 래밸 |
| :---: | :--- | :---: |
| **11.3.1** | 안전하지 않은 블록 모드(예: ECB) 및 약한 패딩 방식(예: PKCS#1 v1.5)가 사용되지 않는지 검증해야 한다. | 1 |
| **11.3.2** | GCM을 사용하는 AES와 같이 승인된 암호 및 모드만 사용되는지 검증해야 한다. | 1 |
| **11.3.3** | 암호화 된 데이터가 승인된 인증된 암호화 방식을 사용하거나, 승인된 암호화 방식과 승인된 MAC 알고리즘을 조합을 통한 무단 수정으로부터 보호되는지 검증해야 한다. | 2 |
| **11.3.4** | 논스(nonces), 초기화 벡터 및 기타 단일 사용 번호가 둘 이상의 암호화 키 및 데이터 요소 쌍에 사용되지 않는지 검증해야 한다. 생성 방법은 사용되는 알고리즘에 적합해야 한다. | 3 |
| **11.3.5** | 암호화 알고리즘과 MAC 알고리즘의 모든 조합이 암호화 후 MAC(Encrypt-then-MAC) 방식으로 동작하는지 검증해야 한다. | 3 |

## V11.4 해싱 및 해시 기반 함수

암호화 해시는 디지털 서명, HMAC, 키 유도 함수(KDF), 무작위 비트 생성 및 비밀번호 저장과 같은 다양한 암호화 프로토콜에서 사용된다. 암호화 시스템의 보안은 사용되는 기본 해시 함수의 강도에 달려 있다. 이 섹션에서는 암호화 작업에서 안전한 해시 함수를 사용하는 요구 사항을 설명한다.

비밀번호 저장 및 암호화 부록의 경우, [OWASP 비밀번호 저장 치트 시트](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#password-hashing-algorithms)도 유용한 맥락과 지침을 제공할 것이다.

| # | 설명 | 래밸 |
| :---: | :--- | :---: |
| **11.4.1** | 디지털 서명, HMAC, KDF 및 무작위 비트 생성을 포함한 일반적인 암호화 사용 사례에 승인된 해시 함수만 사용되는지 검증해야 한다. MD5와 같이 허용되지 않는 해시 함수는 어떤 암호화 목적으로도 사용해서는 안 된다. | 1 |
| **11.4.2** | 비밀번호가 승인된 '계산 집약적인 키 유도 함수("비밀번호 해싱 함수"라고도 함)'를 사용하여 저장되고, 파라미터 설정이 현재 지침에 따라 구성되었는지 검증해야 한다. 설정은 필요한 보안 수준에 대한 무차별 대입 공격을 충분히 어렵게 만들기 위해 보안과 성능의 균형을 이루어야 한다. | 2 |
| **11.4.3** | 데이터 인증 또는 데이터 무결성의 일부로 디지털 서명에 사용되는 해시 함수가 충돌 저항성을 가지며 적절한 비트 길이를 갖는지 검증해야 한다. 충돌 저항성이 필요한 경우, 출력 길이는 최소 256비트여야 한다. 제2 역상(pre-image) 공격 저항성만 필요한 경우, 출력 길이는 최소 128비트여야 한다. | 2 |
| **11.4.4** | 비밀번호로부터 비밀 키를 유도할 때 애플리케이션이 키 스트레칭(key stretching) 파라미터를 사용하여 승인된 키 유도 함수(key derivation function)를 사용하는지 검증해야 한다. 사용 중인 파라미터는 결과적인 암호화 키를 손상시키는 무차별 대입 공격을 방지하기 위해 보안과 성능의 균형을 이루어야 한다. | 2 |

## V11.5 무작위 값

암호학적으로 안전한 의사 난수 생성(CSPRNG)은 올바르게 구현하기가 매우 어렵다. 일반적으로 시스템 내의 좋은 엔트로피 소스는 과도하게 사용될 경우 빠르게 고갈되지만, 무작위성이 적은 소스는 예측 가능한 키와 비밀로 이어질 수 있다.

| # | 설명 | 래밸 |
| :---: | :--- | :---: |
| **11.5.1** | 예측 불가능해야 하는 모든 난수 및 문자열이 암호학적으로 안전한 의사 난수 생성기(CSPRNG)를 사용하여 생성되고 최소 128비트의 엔트로피를 갖는지 검증해야 한다. UUID는 이 조건을 충족하지 않는다. | 2 |
| **11.5.2** | 사용 중인 난수 생성 메커니즘이 높은 부하(heavy demand)에서도 안전하게 작동하도록 설계되었는지 검증해야 한다. | 3 |

## V11.6 공개 키 암호화

공개 키 암호화는 여러 당사자 간에 비밀 키를 공유하는 것이 불가능하거나 바람직하지 않은 경우에 사용될 것이다.

이의 일부로, 디피-헬만(Diffie-Hellman) 및 타원 곡선 디피-헬만(Elliptic Curve Diffie-Hellman; ECDH)과 같은 승인된 키 교환 메커니즘이 필요하여 암호화 시스템이 현대 위협에 대해 안전하게 유지되도록 한다. "V12 안전한 통신" 챕터는 TLS에 대한 요구 사항을 제공하므로 이 섹션의 요구 사항은 TLS 이외의 사용 사례에서 공개 키 암호화가 사용되는 상황을 위한 것이다.

| # | 설명 | 래밸 |
| :---: | :--- | :---: |
| **11.6.1** | 키 생성 및 시딩, 디지털 서명 생성 및 검증에 승인된 암호화 알고리즘 및 작동 모드만 사용되는지 검증해야 한다. 키 생성 알고리즘은 알려진 공격에 취약한 안전하지 않은 키(예: 페르마 인수분해(Fermat factorization)에 취약한 RSA 키)를 생성해서는 안 된다. | 2 |
| **11.6.2** | 키 교환에는 디피-헬만과 같은 승인된 암호화 알고리즘이 사용되어야 하며, 안전한 파라미터를 사용하는지 여부를 중점적으로 검증해야 한다.이는 중간자 공격(adversary-in-the-middle attacks) 또는 암호화 해독으로 이어질 수 있는 키 설정 프로세스에 대한 공격을 방지할 것이다. | 3 |

## V11.7 사용 중 데이터 암호화

데이터가 처리되는 동안 데이터를 보호하는 것은 매우 중요하다. 이를 위해 전체 메모리 암호화, 전송 중 데이터 암호화, 그리고 데이터 사용 직후 가능한 한 빠르게 암호화하는 방식 등의 기술을 적용하는 것이 권장된다.

| # | 설명 | 래밸 |
| :---: | :--- | :---: |
| **11.7.1** | 사용 중인 민감한 데이터를 보호하고 무단 사용자 또는 프로세스의 접근을 방지하기 위해 전체 메모리 암호화가 사용되는지 검증해야 한다. | 3 |
| **11.7.2** | 데이터 최소화가 처리 중에 노출되는 데이터의 양을 최소화하고, 사용 직후 또는 가능한 한 빨리 데이터가 암호화되도록 보장하는지 검증해야 한다. | 3 |

## 참조

더 많은 정보는 다음을 참고한다:

* [OWASP 웹 보안 테스팅 가이드: 취약한 암호화 테스트](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography)
* [OWASP 암호화 저장 치트 시트](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)
* [FIPS 140-3](https://csrc.nist.gov/pubs/fips/140-3/final)
* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)
