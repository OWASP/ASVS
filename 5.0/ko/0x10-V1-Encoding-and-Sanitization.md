# V1 인코딩과 데이터 정제

## 제어 목표

이번 장에서는 신뢰할 수 없는 데이터를 안전하지 않게 처리하여 발생하는 가장 흔한 웹 애플리케이션 보안 취약점들을 다룬다. 이러한 취약점들은 신뢰할 수 없는 데이터가 관련 인터프리터의 문법 규칙에 따라 해석되면서 다양한 기술적 취약점들로 이어질 수 있다.

현대의 웹 애플리케이션에서는 파라미터화된 쿼리, 자동 이스케이핑, 또는 템플릿 프레임워크와 같은 더 안전한 응용 프로그램 프로그래밍 인터페이스(Application Programming Interface; API)들을 쓰는 것이 항상 가장 좋다. 즉, 출력값 인코딩, 이스케이핑, 또는 데이터 정제를 신중하게 처리하는 것은 애플리케이션의 보안에 매우 중요하다.

입력값 검증은 예상치 못한 입력이나 위험한 콘텐츠로부터 보호하기 위한 심층 방어(Defense-in-Depth; DID) 메커니즘 역할을 한다. 다만, 입력값 검증의 주요 목적은 입력된 데이터가 기능 및 비즈니스 요구사항에 부합하는지를 확인하는 데 있으므로, 이에 관련된 요구사항은 "검증 및 비즈니스 로직" 장에서 다루고 있다.

## V1.1 인코딩 및 데이터 정제 아키텍처

아래의 섹션에서는 위험한 콘텐츠를 안전하게 처리하여 보안 취약점을 방지하기 위한 문법 또는 인터프리터별 요구사항들이 제시된다. 이 요구사항들은 처리가 이루어져야 할 순서와 위치에 대한 내용도 포함하고 있다. 또한 데이터가 저장될 때 인코딩 되거나 이스케이프 된 형태(예: HTML 인코딩)가 아닌 원래의 상태로 저장되도록 보장함으로써 이중 인코딩 문제를 방지하는 데 목적이 있다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **1.1.1** | 입력값 검증은 오직 한 번만 표준 형태로 디코딩 되거나 언이스케이프 되어야 하며, 인코딩된 데이터가 예상될 때만 디코딩 되어야한다. 이 과정은 입력이 추가로 처리되기 전에 완료되어야 한다. 예를 들어서 입력값 검증이나 데이터 정제 이후에는 수행되면 안 된다. | 2 |
| **1.1.2** | 애플리케이션이 출력값 인코딩 또는 이스케이핑을 인터프리터가 사용하기 전의 최종 단계로 수행하거나 인터프리터 자체에서 처리하는지 검증해야 한다. | 2 |

## V1.2 인젝션(Injection) 방지

잠재적으로 위험 컨텍스트(context)에 인접하거나 가까운 위치에서 수행되는 출력값 인코딩이나 이스케이핑은 애플리케이션의 보안에 매우 중요하다. 일반적으로 출력값 인코딩과 이스케이핑은 저장되지 않으며, 대신 해당 출력값을 적절한 인터프리터에서 즉시 안전하게 렌더링하기 위해 사용된다. 이를 너무 이른 시점에 수행하려고 하면 콘텐츠가 잘못 구성되거나 인코딩 및 이스케이핑이 무효화될 수 있다.

많은 경우에서 소프트웨어 라이브러리에는 이를 자동으로 처리하는 안전한 함수들이 포함되어 있지만 현재 컨텍스트에 적합한지 확인이 필요하다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **1.2.1** | HTTP 응답, HTML 문서 또는 XML 문서에 대한 출력값 인코딩이 해당 컨텍스트에 적절한지 검증해야 한다. 예를 들어, 메시지나 문서 구조가 변경되지 않도록 HTML 요소, HTML 속성, HTML 주석, CSS, HTTP 헤더 필드 등에 맞는 문맥별 문자 인코딩이 수행되어야 한다. | 1 |
| **1.2.2** | 통합 자원 식별자(Uniform Resource Locator; URL)들을 동적으로 생성할 때 신뢰할 수 없는 데이터가 해당 컨텍스트에 맞게 인코딩되었는지 검증해야 한다(예: 쿼리나 경로 파라미터에 대한 URL 인코딩 또는 base64url 인코딩). 또한, 오직 안전한 URL 프로토콜만이 허용되는지 검증해야 한다(예: javascript: 또는 data:를 허용하지 않음). | 1 |
| **1.2.3** | 동적으로 자바스크립트 콘텐츠(JSON 포함)를 생성할 때 메시지나 문서 구조를 바꾸는 것을 방지하기 위해 출력값 인코딩이나 이스케이핑이 사용되고 있는지 검증해야 한다(자바스크립트 또는 JSON 인젝션을 피하기 위함). | 1 |
| **1.2.4** | 데이터 선택 혹은 데이터베이스 쿼리(예: SQL, HQL, NoSQL, Cypher)들 파라미터화된 쿼리, 객체 관계 매핑(Object Relational Mapping; ORM), 엔티티 프레임워크, 또는 다른 구조화된 쿼리 언어(Structured Query Language; SQL) 인젝션 및 기타 데이터베이스 인젝션 공격으로부터 보호해 주는 것들을 사용하는지 검증해야 한다. 이는 저장 프로시저를 쓸 때도 마찬가지이다. | 1 |
| **1.2.5** | 애플리케이션이 운영체제(Operating System; OS) 명령 인젝션으로부터 보호되며 운영체제 호출 시 파라미터화된 OS 쿼리나 상황에 맞는 명령줄 출력값 인코딩을 사용하는지 검증해야 한다. | 1 |
| **1.2.6** | 애플리케이션이 경량 디렉터리 접근 프로토콜(Lightweight Directory Access Protocol; LDAP) 인젝션 취약점에 대해 보호되어 있는지, 또는 LSAP 인젝션을 방지하기 위한 특정 보안 통제가 구현되어 있는지 검증해야 한다. | 2 |
| **1.2.7** | 애플리케이션이 XPath 인젝션 공격을 쿼리 파라미터나 미리 컴파일된 쿼리들을 사용해 보호되고 있는지 검증해야 한다.. | 2 |
| **1.2.8** | LaTeX 프로세서가 안전하게 구성되어 있으며("--shell-escape" 플래그 비사용 등) LaTex 인젝션 공격을 방지하기 위해 허용된 명령어 목록이 사용되고 있는지 검증해야 한다. | 2 |
| **1.2.9** | 애플리케이션이 정규 표현식에서 특수 문자들을 메타 문자로 잘못 해석하는 것을 방지하기 위해 해당 문자들 이스케이프(보통 백슬래시를 사용)하고 있는지 검증해야 한다. | 2 |
| **1.2.10** | 애플리케이션이 쉼표 구분 데이터(Comma Separated Values; CSV) 및 수식 인젝션에 대해 보호되어 있는지 검증해야 한다. 그리고 애플리케이션은 CSV 콘텐츠를 내보낼 때 RFC 4180 2.6과 2.7 부분에 명시된 이스케이핑 규칙을 반드시 따라야 한다. 또한 CSV나 다른 스프레드시트 포맷(XLS, XLSX, ODF 등)으로 내보낼 때 필드 값의 첫 번째가 특수 문자('=', '+', '-', '@', '\t' (탭), '\0' (null 문자) 포함)라면 반드시 작은따옴표로 이스케이프되어야 한다. | 3 |

참고: 파라미터화된 쿼리를 사용하거나 SQL을 이스케이핑만으로 항상 충분하지 않다. 테이블명과 컬럼명("ORDER BY" 컬럼 이름을 포함)과 같은 쿼리의 일부는 이스케이프 될 수 없다. 이러한 필드에 이스케이프된 사용자 입력 데이터를 포함하면 쿼리가 실패하거나 SQL 인젝션에 취약해질 수 있다.

## V1.3 데이터 정제

신뢰할 수 없는 콘텐츠를 안전하지 않은 컨텍스트에서 사용하는 것을 이상적으로 방지하는 방법은 해당 컨텍스트에 맞는 인코딩 또는 이스케이핑을 사용하는 것이다. 이를 통해 안전하지 않은 콘텐츠의 시맨틱(semantic) 의미는 그대로 유지하면서 해당 컨텍스트를 안전하게 유지할 수 있다. 이에 대한 자세한 내용은 앞 부분에서 다루었다.

이와 같은 처리가 불가능한 경우에 잠재적으로 위험한 문자나 콘텐츠를 제거하는 데이터 정제는 필수적이다. 일부 경우에 이로 인해 입력의 시맨틱 의미가 바뀔 수 있다. 그러나 보안상의 이유로 다른 대안이 없을 수 있다.
| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **1.3.1** | 위지윅(WYSIWYG) 에디터나 이와 유사한 것으로부터 오는 모든 신뢰할 수 없는 HTML 입력들은 잘 알려지고 안전한 HTML 데이터 정제 라이브러리나 프레임워크 기능을 사용해 정제되는지 검증해야 한다. | 1 |
| **1.3.2** | 애플리케이션이 eval() 또는 스프링 표현 언어(Spring Expression Language; SpEL) 등과 같은 동적 코드 실행 기능 사용을 피하고 있는지 검증해야 한다. 대안이 없는 경우, 실행 전에 포함되는 모든 사용자 입력이 반드시 정제되어야 한다. | 1 |
| **1.3.3** | 잠재적으로 위험한 컨텍스트에 전달되는 데이터가 사전에 정제되어 안전 조치가 적용되는지 검증해야 한다. 예를 들어 해당 컨텍스트에서 안전한 문자만 허용하고 너무 긴 입력값은 잘라내는 등의 조치가 포함된다. | 2 |
| **1.3.4** | 사용자로부터 제공된 확장 가능한 벡터 그래픽(Scalable Vector Graphics; SVG)의 스크립트 실행 가능 콘텐츠가 애플리케이션에 안전한 태그 및 속성(예: 그래픽 그리기)만 포함하도록 검증 또는 정제되는지 검증해야 한다. 예를 들어 스크립트나 foreignObject는 포함되면 안 된다. | 2 |
| **1.3.5** | 애플리케이션이 사용자로부터 제공된 스크립트 실행 가능하거나 표현식 템플릿 언어(예: 마크다운, CSS, XSL 스타일시, BBCode ) 콘텐츠를 정제하거나 비활성화하는지 검증해야 한다. | 2 |
| **1.3.6** | 애플리케이션이 서버측 요청 위조(Server-side Request Forgery; SSRF) 공격으로부터 보호하기 위해 신뢰할 수 없는 데이터를 프로토콜, 도메인, 경로, 포트의 허용 목록과 대조해 검증하고 다른 서비스를 호출하기 전에 잠재적으로 위험한 문자를 정제(sanitization)하는지 검증해야 한다. | 2 |
| **1.3.7** | 애플리케이션이 템플릿 인젝션 공격으로부터 보호하기 위해 신뢰할 수 없는 입력값을 기반으로 템플릿을 생성하지 않도록 하는지 검증해야 한다. 대안이 없는 경우에는 템플릿 생성 과정에서 동적으로 포함되는 모든 신뢰할 수 없는 입력값은 정제되거나 엄격히 검증되어야 한다. | 2 |
| **1.3.8** | 애플리케이션이 자바 명명 및 디렉터리 인터페이스(Java Naming and Directory Interface; JNDI) 쿼리에서 신뢰할 수 없는 입력값을 사용하기 전에 적절히 정제하고 JNDI가 JNDI 인젝션 공격을 방지할 수 있도록 안전하게 구성되어 있는지 검증해야 한다. | 2 |
| **1.3.9** | 인젝션을 방지하기 위해 애플리케이션이 메모리 캐시에 콘텐츠를 전달하기 전에 해당 데이터를 정제하는지 검증해야 한다.  | 2 |
| **1.3.10** | 사용 시 예상치 못하거나 악의적인 방식으로 작동할 수 있는 포맷 스트링(format string)들은 처리되기 전에 정제되는지 검증해야 한다. | 2 |
| **1.3.11** | 단순 메일 전송 프로토콜(Simple Mail Transfer Protocol; SMTP)이나 인터넷 메시지 액세스 프로토콜(Internet Message Access Protocol; IMAP) 인젝션으로부터 보호하기 위해 애플리케이션이 사용자 입력을 메일 시스템으로 보내기 전에 정제를 하는지 검증해야 한다. | 2 |
| **1.3.12** | 정규 표현식에 지수형 백트래킹을 유발하는 요소가 없는지, 또한 신뢰할 수 없는 입력값을 정제하여 정규식 기반 서비스 거부 공격(Regular Expression Denial of Service; ReDoS) 또는 런어웨이(Runaway) 정규식 공격을 방지하는지 검증해야 한다. | 3 |

## V1.4 메모리, 스트링, 비관리 코드

애플리케이션이 스택, 버퍼, 또는 힙 오버플로를 탐지하거나 방지하기 위해 안전한 메모리 안전 문자열, 안전한 메모리 복사 및 포인터 산술을 사용하는지 검증해야 한다.

일부 경우에는 컴파일러 플래그를 설정하여 버퍼 오버플로우 방지 및 경고 기능을 활성화함으로써 보호할 수 있다. 이에는 스택 무작위화, 데이터 실행 방지 등이 포함되고 위험한 포인터, 메모리, 포맷 문자열, 정수 또는 문자열 연산이 발견될 경우 빌드를 중단하도록 설정할 수도 있다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **1.4.1** | 애플리케이션이 스택, 버퍼, 또는 힙 오버플로를 탐지하거나 방지하기 위해 안전한 메모리 안전 문자열, 안전한 메모리 복사 및 포인터 산술을 사용하는지 검증해야 한다. | 2 |
| **1.4.2** | 정수 오버플로를 방지하기 위해 부호 확인, 범위 검사, 입력값 검증 등의 기법이 사용되고 있는지 검증해야 한다. | 2 |
| **1.4.3** | 댕글링 포인터(dangling pointer)나 해체 후 사용(Use After Free; UAF) 취약점을 방지하기 위해 동적으로 할당된 메모리와 자원이 적절히 해제되었는지 그리고 해제된 메모리를 참조하는 포인터나 참조가 제거되었거나 null로 설정되었는지를 검증해야 한다. | 2 |

## V1.5 안전한 역직렬화

저장되었거나 전송된 데이터를 애플리케이션의 실제 객체로 변환하는 과정(역직렬화)은 역사적으로 다양한 코드 인젝션 취약점의 원인이 되어왔다. 이 과정을 조심스럽고 안전하게 수행하는 것은 이러한 종류의 문제를 피하는데 중요하다.

특히, 일부 역직렬화 방법은 프로그래밍 언어나 프레임워크 문서에서 안전하지 않거나 신뢰할 수 없는 데이터를 안전하게 만들 수 없다고 지정되어 왔다. 사용 중인 각 메커니즘에 대해 신중한 검토(실사)를 수행해야 한다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **1.5.1** | 애플리케이션이 확장 가능한 마크업 언어(eXtensible Markup Language; XML) 파서(parser)를 제한적인 설정으로 구성하고 외부 엔티티 해석과 같은 안전하지 않은 기능을 비활성화하여 XML 외부 엔티티(XML eXternal Entity; XXE) 공격을 방지하는지 검증해야 한다. | 1 |
| **1.5.2** | 역직렬화 공격을 방지하기 위해 신뢰할 수 없는 데이터의 역직렬화 시 객체 타입 허용 목록 사용 또는 클라이언트 정의 객체 타입 제한과 같은 안전한 입력 처리 방식이 적용되는지 검증해야 한다. 또한 명확히 안전하지 않은 것으로 지정된 역직렬화 메커니즘은 신뢰할 수 없는 입력에 대해 반드시 사용해서는 안 된다. | 2 |
| **1.5.3** | 애플리케이션에서 동일한 데이터 타입(예: JSON 파서, XML 파서, URL 파서)에 대해 사용되는 서로 다른 파서들이 일관된 방식으로 파싱(parsing)을 수행하고 동일한 문자 인코딩 방식을 사용하는지 검증해야 한다. 이를 통해 자바스크립트 객체 표기법(JavaScript Object Notation; JSON) 상호운용 취약점이나 원격 파일 포함(Remote File Inclusion; RFI) 및 SSRF 공격에서 악용될 수 있는 서로 다른 URI 또는 파일 파싱 동작 문제를 방지할 수 있다. | 3 |

## 참고자료

자세한 내용은 다음을 참조:

* [OWASP LDAP 인젝션 방지 치트 시트(Cheat Sheet)](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)
* [OWASP 사이트 간 스크립팅(Cross Site Scripting; XSS) 방지 치트 시트](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
* [OWASP 문서 객체 모델(Document Object Model; DOM) 기반 XSS 방지 치트 시트](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)
* [OWASP XXE 방지 치트 시트](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)
* [OWASP 웹 보안 테스트 가이드: 클라이언트 측 테스트](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing)
* [OWASP 자바 인코딩 프로젝트](https://owasp.org/owasp-java-encoder/)
* [DOMPurify - 클라이언트 측 HTML 정제 라이브러리](https://github.com/cure53/DOMPurify)
* [RFC4180 - CSV 파일의 공통 포맷(format) 및 다목적 인터넷 메일 확장(Multipurpose Internet Mail Extensions; MIME) 타입](https://datatracker.ietf.org/doc/html/rfc4180#section-2)

역직렬화 또는 파싱 문제에 대한 자세한 내용은 다음을 참조:

* [OWASP 역직렬화 치트 시트](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)
* [JSON 상호운용 취약점 탐구](https://bishopfox.com/blog/json-interoperability-vulnerabilities)
* [Orange Tsai – 트렌딩(Trending) 프로그래밍 언어의 URL 파서를 악용한 SSRF의 새로운 시대](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)
