# V10 OAuth와 OIDC

## 제어 목표

OAuth2(본 장에서는 OAuth로 지칭)는 권한 위임을 위한 산업 표준 프레임워크이다. 예를 들어, OAuth를 사용하면 클라이언트 애플리케이션은 사용자가 클라이언트 애플리케이션에 권한을 위임한 경우 사용자를 대신하여 API(서버 리소스)에 접근할 수 있다.

OAuth 자체는 사용자 인증을 위해 설계되지 않았다. OpenID Connect(OIDC) 프레임워크는 OAuth 위에 사용자 식별 계층을 추가하여 OAuth를 확장한다. OIDC는 표준화된 사용자 정보, 싱글 사인온(SSO), 세션 관리 등의 기능을 지원한다. OIDC는 OAuth를 확장한 표준 사양이므로 본 장의 OAuth 요구사항은 OIDC에도 적용된다.

OAuth에 정의된 역할은 다음과 같다:

* OAuth 클라이언트는 서버 리소스에 접근하려는 애플리케이션이다(예: 발급된 액세스 토큰을 사용하여 API 호출). OAuth 클라이언트는 서버에서 동작하는 애플리케이션인 경우가 많다.
    * 기밀 클라이언트는 인가 서버에 자체적으로 인증하는 데 사용하는 자격 증명(Credentials)의 기밀성을 유지할 수 있는 클라이언트이다.
    * 공개 클라이언트는 인가 서버에 인증하기 위한 자격 증명의 기밀성을 유지할 수 없다. 따라서 자체적으로 인증(예: 'client_id' 및 'client_secret' 파라미터 사용)하는 대신, 자체 식별만 한다('client_id' 파라미터 사용).
* OAuth 리소스 서버는 OAuth 클라이언트에 리소스를 제공하는 서버 API이다.
* OAuth 인가 서버는 OAuth 클라이언트에 액세스 토큰을 발급하는 서버 애플리케이션이다. 이 액세스 토큰을 통해 OAuth 클라이언트는 최종 사용자를 대신하여 또는 OAuth 클라이언트 자체를 대신하여 리소스 서버의 리소스에 접근할 수 있다. 인가 서버는 종종 별도의 애플리케이션이지만, (적절한 경우) 요건에 맞는 리소스 서버에 통합될 수 있다.
* 리소스 소유자는 리소스 서버에 호스팅된 리소스에 대해 제한된 접근 권한을 획득하도록 OAuth 클라이언트에 권한을 위임하는 최종 사용자이다. 리소스 소유자는 인가 서버와 상호 작용함으로써 이 권한 위임에 동의한다.

OIDC에 정의된 역할은 다음과 같다:

* 신뢰 당사자(Relying Party)는 OpenID 공급자를 통해 최종 사용자 인증을 요청하는 클라이언트 애플리케이션이다. 이는 OAuth 클라이언트의 역할을 수행한다.
* OpenID 공급자는 최종 사용자를 인증하고 신뢰 당사자에 OIDC 클레임(claims)을 제공할 수 있는 OAuth 인가 서버이다. OpenID 공급자는 ID 공급자(IdP)일 수 있지만, 연합 인증 시나리오(federated scenarios)에서는 OpenID 공급자와 ID 공급자(최종 사용자가 인증하는 곳)가 다른 서버 애플리케이션일 수 있다.

OAuth와 OIDC는 원래 외부(third-party) 애플리케이션을 위해 설계되었으며, 오늘날에는 내부(first-party) 애플리케이션에서도 종종 사용된다. 그러나 인증 및 세션 관리와 같은 내부 시나리오에서 사용될 때, 프로토콜이 복잡성을 더하게 되며, 이로 인해 새로운 보안 과제가 발생할 수 있다.

OAuth와 OIDC는 다양한 유형의 애플리케이션에 사용될 수 있지만, 본 장의 ASVS와 요구사항은 웹 애플리케이션과 API에 중점을 두고 있다.

OAuth와 OIDC는 웹 기술 위에 구축된 논리 계층으로 간주될 수 있으므로, 본 장의 내용만을 따로 떼어내서 해석하지 않고, 다른 장의 일반 요구사항과 함께 적용해야 한다.

본 장은 <https://oauth.net/2/> 및 <https://openid.net/developers/specs/> 에서 찾을 수 있는 사양에 맞춰 OAuth2 및 OIDC에 대한 현재의 모범 사례를 다룬다. RFC가 성숙하다고 간주되더라도 자주 업데이트된다. 따라서 본 장의 요구사항을 적용할 때 최신 버전과 일치시키는 것이 중요하다. 자세한 내용은 참조 섹션을 확인한다.

이 영역의 복잡성을 고려할 때, 안전한 OAuth 또는 OIDC 솔루션을 위해서는 잘 알려진 산업 표준의 인가 서버를 사용하고, 권장되는 보안 구성을 적용하는 것이 매우 중요하다.

본 장에서 사용되는 용어는 OAuth RFC 및 OIDC 사양과 일치하지만, OIDC 용어는 OIDC에 특화된 요구사항에만 사용되며, 그 외에는 OAuth 용어가 사용된다는 점에 유의해야 한다.

OAuth 및 OIDC의 맥락에서, 본 장의 "토큰"이라는 용어는 다음을 의미한다:

* 액세스 토큰은 리소스 서버에서만 사용되어야 하며, 조회(introspection)를 통해 검증되는 참조 토큰이거나 특정 키 정보를 사용하여 검증되는 자체 포함 토큰일 수 있다.
* 리프레시 토큰은 토큰을 발급한 인가 서버에서만 사용되어야 한다.
* OIDC ID 토큰은 인가 플로우를 시작했던 클라이언트에서만 사용되어야 한다.

본 장의 일부 요구사항의 위험 수준은 클라이언트가 기밀 클라이언트인지, 공개 클라이언트로 간주되는지에 따라 달라질 수 있다. 강력한 클라이언트 인증을 사용하면 많은 공격 벡터를 줄일 수 있으므로, L1 애플리케이션에서 기밀 클라이언트를 사용하는 경우 일부 요구사항이 완화될 수 있다.

## V10.1 일반적인 OAuth 및 OIDC 보안

이 섹션은 OAuth 또는 OIDC를 사용하는 모든 애플리케이션에 적용되는 일반적인 아키텍처 요구사항을 다룬다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **10.1.1** | 엄격하게 필요한 구성 요소에만 토큰이 전송되는지 검증해야 한다. 예를 들어, 브라우저 기반 JavaScript 애플리케이션에 프론트엔드 전용 백엔드(Backend For Frontend; BFF) 패턴을 사용하는 경우, 액세스 토큰 및 리프레시 토큰은 백엔드에서만 접근 가능해야 한다. | 2 |
| **10.1.2** | 클라이언트는 인가 서버에서 제공하는 값(예: 인가 코드 또는 ID 토큰)이 동일한 사용자 에이전트 세션 및 트랜잭션에서 시작된 인가 플로우의 결과인 경우에만 허용하는지 검증해야 한다. 이를 위해 클라이언트가 생성하는 비밀 값(PKCE(Proof Key for Code Exchange)의 'code_verifier', 'state', OIDC의 'nonce' 등)은 추측이 불가능해야 하며, 해당 트랜잭션에 고유해야 하고, 트랜잭션이 시작된 클라이언트와 사용자 에이전트 세션 양쪽에 안전하게 결합(Binding)되어 있어야 한다. | 2 |

## V10.2 OAuth 클라이언트

이 요구사항은 OAuth 클라이언트 애플리케이션의 책임을 상세히 규정한다. 예를 들어 클라이언트는 웹 서버 백엔드(일반적으로 BFF 역할 수행), 백엔드 서비스 통합, 또는 프론트엔드 단일 페이지 애플리케이션(브라우저 기반 애플리케이션)일 수 있다.

일반적으로 백엔드 클라이언트는 기밀 클라이언트로 간주되고, 프론트엔드 클라이언트는 공개 클라이언트로 간주된다. 그러나 최종 사용자 장치에서 실행되는 네이티브 애플리케이션은 OAuth 동적 클라이언트 등록을 사용하는 경우 기밀로 간주될 수 있다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **10.2.1** | 코드 플로우를 사용하는 경우, OAuth 클라이언트는 토큰 요청을 유도하는 사이트 간 요청 위조 공격(Cross-Site Request Forgery; CSRF)에 대한 보호 기능을 갖추고 있는지 검증한다. 이를 위해 인가 요청 시 전송된 'state' 파라미터를 검증하거나, PKCE 기능을 사용해야 한다. | 2 |
| **10.2.2** | OAuth 클라이언트가 둘 이상의 인가 서버와 상호 작용할 수 있는 경우, 믹스업 공격에 대한 방어 대책을 갖는지 검증해야 한다. 예를 들어, 인가 서버가 'iss' 파라미터 값을 반환하도록 요구하고 인가 응답 및 토큰 응답에서 이를 검증할 수 있다. | 2 |
| **10.2.3** | OAuth 클라이언트가 인가 서버에 대한 요청에서 필요한 범위(또는 기타 인가 파라미터)만 요청하는지 검증해야 한다. | 3 |

## V10.3 OAuth 리소스 서버

ASVS 및 본 장의 맥락에서 리소스 서버는 API를 의미한다. 안전한 접근 제어를 제공하기 위해 리소스 서버는 다음을 수행해야 한다:

* 토큰 형식 및 관련 프로토콜 사양(예: JWT 검증 또는 OAuth 토큰 조회)에 따라 액세스 토큰을 검증해야 한다.
* 토큰이 유효한 경우, 액세스 토큰의 정보 및 부여된 권한을 기반으로 인가 결정을 강제해야 한다. 예를 들어, 리소스 서버는 클라이언트(리소스 소유자를 대신하여 작동)가 요청된 리소스에 접근할 권한이 있는지 검증해야 한다.

따라서 여기에 나열된 요구사항은 OAuth 또는 OIDC에 특화되어 있으며, 토큰 검증 후 토큰의 정보를 기반으로 인가를 수행하기 전에 이행되어야 한다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **10.3.1** | 리소스 서버가 해당 서비스(audience)에 사용하도록 의도된 액세스 토큰만 수락하는지 검증해야 한다. 대상은 구조화된 액세스 토큰(예: JWT의 'aud' 클레임)에 포함될 수 있거나, 토큰 조회 엔드포인트를 사용하여 확인할 수 있다. | 2 |
| **10.3.2** | 리소스 서버가 위임된 인가를 정의하는 액세스 토큰의 클레임을 기반으로 인가 결정을 시행하는지 검증해야 한다. 'sub', 'scope', 'authorization_details'와 같은 클레임이 존재하는 경우, 이는 결정에 반영되어야 한다. | 2 |
| **10.3.3** | 액세스 토큰(JWT 또는 관련 토큰 조회 응답)에서 고유한 사용자를 식별해야 하는 접근 제어 결정이 필요한 경우, 리소스 서버가 다른 사용자에게 재할당될 수 없는 클레임에서 사용자를 식별하는지 검증해야 한다. 일반적으로 이는 'iss' 및 'sub' 클레임의 조합을 사용하는 것을 의미한다. | 2 |
| **10.3.4** | 리소스 서버가 특정 인증 강도, 방법 또는 최신성을 요구하는 경우, 제시된 액세스 토큰이 이러한 제약 조건을 충족하는지 검증해야 한다. 예를 들어, 토큰을 제시한 경우 OIDC의 'acr', 'amr' 및 'auth_time' 클레임을 각각 사용해야 한다. | 2 |
| **10.3.5** | 리소스 서버가 발신자 제약 액세스 토큰, 즉 OAuth 2용 상호 TLS(Mutual TLS; mTLS) 또는 OAuth 2 소유 증명(Demonstration of Proof of Possession; DPoP)를 요구하여 도난된 액세스 토큰 사용 또는 액세스 토큰 재사용(권한 없는 당사자로부터)을 방지하는지 검증해야 한다. | 3 |

## V10.4 OAuth 인가 서버

이 요구사항은 OpenID 공급자를 포함한 OAuth 인가 서버의 책임을 상세히 설명한다.

클라이언트 인증의 경우, 'self_signed_tls_client_auth' 메소드는 [RFC 8705](https://datatracker.ietf.org/doc/html/rfc8705)의 [섹션 2.2](https://datatracker.ietf.org/doc/html/rfc8705#name-self-signed-certificate-mut)에서 요구하는 전제조건을 충족하는 경우에 허용된다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **10.4.1** | 인가 서버는 클라이언트 별로 사전 등록된 URI의 허용 목록을 기반으로 리디렉션 URI를 정확한 문자열 비교 방식으로 검증해야 한다. | 1 |
| **10.4.2** | 인가 서버가 인가 응답에서 인가 코드를 반환하는 경우, 해당 코드는 토큰 요청에 한번만 사용될 수 있어야 한다. 이미 액세스 토큰을 발급하는 데 사용된 인가 코드를 사용하여 두 번째 요청이 발생하면, 인가 서버는 토큰 요청을 거부하고 해당 인가 코드와 관련된 모든 발급된 토큰을 취소해야 한다. | 1 |
| **10.4.3** | 인가 코드가 단기간만 유효한지 검증해야 한다. 최대 수명은 L1 및 L2 애플리케이션의 경우 최대 10분, L3 애플리케이션의 경우 최대 1분 이내여야 한다. | 1 |
| **10.4.4** | 인가 서버는 특정 클라이언트에 대해, 해당 클라이언트가 사용할 필요가 있는 인가 방식(grant)만 사용하도록 허용해야 한다. token(암시적 플로우) 및 password(리소스 소유자 비밀번호 자격 증명 플로우) 방식은 더 이상 사용되어서는 안 된다. | 1 |
| **10.4.5** | 인가 서버가 공개 클라이언트에 대한 리프레시 토큰 재사용 공격을 완화하는지 검증해야 한다. 가급적이면 발신자 제약 리프레시 토큰, 즉 소유 증명이나 mTLS를 사용한 인증서 바인딩 액세스 토큰을 사용해야 한다. L1 및 L2 애플리케이션의 경우, 리프레시 토큰 회전(rotation)이 사용될 수 있다. 리프레시 토큰 회전이 사용되는 경우, 인가 서버는 리프레시 토큰을 사용 후 무효화해야 하며, 이미 사용되고 무효화된 리프레시 토큰이 제공되면 해당 인가에 대한 모든 리프레시 토큰을 철회(revoke)해야 한다. | 1 |
| **10.4.6** | 코드 인가 방식(code grant)이 사용되는 경우, 인가 서버가 PKCE를 요구하여 인가 코드 탈취 공격을 완화하는지 검증해야 한다. 인가 요청의 경우, 인가 서버는 유효한 'code_challenge' 값을 요구해야 하며, 'code_challenge_method'값으로 'plain'를 허용해서는 안 된다. 토큰 요청의 경우, 'code_verifier' 파라미터의 검증을 요구해야 한다. | 2 |
| **10.4.7** | 인가 서버가 인증되지 않은 동적 클라이언트 등록을 지원하는 경우, 악의적인 클라이언트 애플리케이션의 위험을 완화하는지 검증해야 한다. 등록된 URI와 같은 클라이언트 메타데이터를 검증하고, 사용자의 동의를 확인해야 하며, 신뢰할 수 없는 클라이언트 애플리케이션으로 인가 요청을 처리하기 전에 사용자에게 경고해야 한다. | 2 |
| **10.4.8** | 슬라이딩 리프레시 토큰 만료(expiration)가 적용되더라도, 리프레시 토큰에 절대 만료 시점(absolute expiration)이 포함되어 있는지 확인한다. | 2 |
| **10.4.9** | 악의적인 클라이언트 또는 도난된 토큰의 위험을 완화하기 위해 인가 서버 사용자 인터페이스를 통해 권한 있는 사용자가 리프레시 토큰 및 참조 액세스 토큰을 철회할 수 있는지 검증해야 한다. | 2 |
| **10.4.10** | 토큰 요청, 푸시된 인가 요청(Pushed Authorization Request; PAR), 토큰 철회 요청과 같은 클라이언트에서 인가 서버로의 백채널 요청(backchannel request)에 대해 기밀 클라이언트가 인증되는지 검증해야 한다. | 2 |
| **10.4.11** | 인가 서버 구성이 OAuth 클라이언트에 필요한 범위만 할당하는지 검증해야 한다. | 2 |
| **10.4.12** | 주어진 클라이언트에 대해 인가 서버가 해당 클라이언트가 사용해야 하는 'response_mode' 값만 허용하는지 검증해야 한다. 예를 들어, 인가 서버가 이 값을 예상 값과 비교하여 검증하거나, PAR 또는 JWT 기반 인가 요청(JWT-secured Authorization Request; JAR)을 사용하여 검증해야 한다. | 3 |
| **10.4.13** | 인가 유형 'code'가 항상 PAR과 함께 사용되는지 검증해야 한다. | 3 |
| **10.4.14** | 인가 서버가 mTLS를 사용하는 인증서 바인딩 액세스 토큰 또는 소유 증명 바인딩 액세스 토큰을 사용하여 발신자 제약(Proof-of-Possession) 액세스 토큰만 발급하는지 검증해야 한다. | 3 |
| **10.4.15** | 최종 사용자 장치에서 실행되지 않는 서버에서 동작하는 클라이언트의 경우, 인가 서버가 'authorization_details' 파라미터 값이 클라이언트 백엔드로부터 생성되었는지와 사용자가 해당 값을 변조되지 않았는지를 검증해야 한다. 예를 들어, PAR 또는 JAR의 사용을 요구하여 확인해야 한다. | 3 |
| **10.4.16** | 클라이언트가 기밀 클라이언트인지 검증하고, 인가 서버는 재사용 공격에 강하고 공개키 암호화에 기반한 강력한 클라이언트 인증 방식을 사용하도록 요구해야 한다. 예를 들어, mTLS(tls_client_auth, self_signed_tls_client_auth) 또는 비공개 키 기반 JWT 인증(private_key_jwt) 등이 이에 해당한다. | 3 |

## V10.5 OIDC 클라이언트

OIDC 신뢰 당사자가 OAuth 클라이언트로 작동하므로, "V10.2 OAuth 클라이언트" 섹션의 요구사항도 적용된다.

"V6 인증" 장의 "V6.8 ID 공급자를 사용한 인증" 섹션에도 관련 일반 요구사항이 포함되어 있음에 유의해야 한다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **10.5.1** | 신뢰 당사자로서 클라이언트가 ID 토큰 재사용 공격을 완화하는지 검증해야 한다. 예를 들어, ID 토큰의 'nonce' 클레임이 OpenID 공급자에 전송된 인증 요청(OAuth2에서는 인가 서버에 전송된 인가 요청)에서 전송된 'nonce' 값과 일치하는지 확인해야 한다. | 2 |
| **10.5.2** | 클라이언트가 ID 토큰 클레임, 일반적으로 'sub' 클레임에서 사용자를 고유하게 식별하며, 해당 클레임이 ID 공급자 범위 내에서 다른 사용자에게 재할당될 수 없는지 검증해야 한다. | 2 |
| **10.5.3** | 클라이언트는 악의적인 인가 서버가 인가 서버 메타데이터를 통해 다른 인가 서버를 가장하려는 시도를 거부하는지 검증해야 한다. 클라이언트는 인가 서버 메타데이터에 포함된 발급자(issuer) URL이 클라이언트가 예상하는 사전 구성된 발급자 URL과 정확히 일치하지 않는 경우, 해당 메타데이터를 거부해야 한다. | 2 |
| **10.5.4** | 클라이언트는 토큰의 aud 클레임 값이 클라이언트의 client_id 값과 동일한지 확인하여 ID 토큰이 해당 클라이언트(audience)를 대상으로 발급되었음을 검증해야 한다. | 2 |
| **10.5.5** | OIDC 백채널 로그아웃을 사용하는 경우, 신뢰 당사자는 강제 로그아웃을 통한 서비스 거부 공격(Denial of Service) 및 로그아웃 플로우에서의 JWT 혼동(cross-JWT confusion)을 완화하는지 검증해야 한다. 클라이언트는 로그아웃 토큰이 'logout+jwt' 값으로 올바르게 지정되어 있는지, 올바른 멤버 이름을 가진 'event' 클레임을 포함하는지, 그리고 'nonce' 클레임을 포함하지 않는지 검증해야 한다. 또한, 짧은 만료 시간(예: 2분)을 갖는 것이 권장된다. | 2 |

## V10.6 OpenID 공급자

OpenID 공급자는 OAuth 인가 서버로 작동하므로, "V10.4 OAuth 인가 서버" 섹션의 요구사항도 적용된다.

ID 토큰 플로우(코드 플로우가 아닌)을 사용하는 경우, 액세스 토큰이 발급되지 않으며 OAuth 인가 서버의 많은 요구사항이 적용되지 않음에 유의해야 한다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **10.6.1** | OpenID 공급자는 response_mode 파라미터 값으로'code', 'ciba', 'id_token' 또는 'id_token code' 만 허용하는지 검증해야 한다. 이 중 'id_token code'(OIDC 하이브리드 플로우)보다는 'code'가 선호되며, 'token'(모든 암시적 플로우)은 사용되어서는 안 된다. | 2 |
| **10.6.2** | OpenID 공급자가 강제 로그아웃을 통한 서비스 거부 공격을 완화하는지 검증해야 한다. 신뢰 당사자로 부터 시작된 로그아웃 요청에 id_token_hint 등의 파라미터가 포함되어 있는 경우, 이를 검증하거나 최종 사용자로부터 명시적인 확인을 받아야 한다. | 2 |


## V10.7 동의 관리

이 요구사항은 인가 서버에 의한 사용자 동의 검증을 다룬다. 적절한 사용자 동의 검증이 없으면 악의적인 행위자가 스푸핑 또는 사회 공학을 통해 사용자를 대신하여 권한을 획득할 수 있다.

| # | 설명 | 레벨 |
| :---: | :--- | :---: |
| **10.7.1** | 인가 서버가 사용자로부터 각 인가 요청에 대한 명시적인 동의(consent)를 확인하는지 검증해야 한다. 클라이언트의 신원을 보장할 수 없는 경우, 인가 서버는 항상 사용자에게 명시적으로 동의를 요청해야 한다. | 2 |
| **10.7.2** | 인가 서버가 사용자 동의를 요청할 때, 동의하는 내용에 대한 충분하고 명확한 정보를 제공하는지 검증해야 한다. 이에 해당하는 경우, 요청된 인가의 성격(일반적으로 범위, 리소스 서버, RAR(Rich Authorization Requests) 인가 세부 정보 기반), 인가된 애플리케이션의 신원, 인가의 유효 기간이 포함되어야 한다. | 2 |
| **10.7.3** | 사용자가 인가 서버를 통해 부여한 동의를 검토, 수정 및 철회할 수 있는지 검증해야 한다. | 2 |

## 참조

더 많은 정보는 다음을 참조한다:

* [oauth.net](https://oauth.net/)
* [OWASP OAuth 2.0 프로토콜 치트 시트](https://cheatsheetseries.owasp.org/cheatsheets/OAuth2_Cheat_Sheet.html)

ASVS에서 OAuth 관련 요구사항은 다음의 공개 및 초안 상태 RFC를 사용한다:

* [RFC6749 OAuth 2.0 인가 프레임워크](https://datatracker.ietf.org/doc/html/rfc6749)
* [RFC6750 OAuth 2.0 인가 프레임워크: 베어러 토큰 사용](https://datatracker.ietf.org/doc/html/rfc6750)
* [RFC6819 OAuth 2.0 위협 모델 및 보안 고려 사항](https://datatracker.ietf.org/doc/html/rfc6819)
* [RFC7636 OAuth 공개 클라이언트를 위한 코드 교환 증명 키](https://datatracker.ietf.org/doc/html/rfc7636)
* [RFC7591 OAuth 2.0 동적 클라이언트 등록 프로토콜](https://datatracker.ietf.org/doc/html/rfc7591)
* [RFC8628 OAuth 2.0 디바이스 인가 부여](https://datatracker.ietf.org/doc/html/rfc8628)
* [RFC8707 OAuth 2.0을 위한 리소스 표시자](https://datatracker.ietf.org/doc/html/rfc8707)
* [RFC9068 OAuth 2.0 액세스 토큰을 위한 JSON 웹 토큰(JWT) 프로파일](https://datatracker.ietf.org/doc/html/rfc9068)
* [RFC9126 OAuth 2.0 푸시된 인가 요청(PAR)](https://datatracker.ietf.org/doc/html/rfc9126)
* [RFC9207 OAuth 2.0 인가 서버 발급자 식별](https://datatracker.ietf.org/doc/html/rfc9207)
* [RFC9396 OAuth 2.0 확장된 인가 요청](https://datatracker.ietf.org/doc/html/rfc9396)
* [RFC9449 OAuth 2.0 PoP(Demonstrating Proof of Possession)](https://datatracker.ietf.org/doc/html/rfc9449)
* [RFC9700 OAuth 2.0 보안을 위한 현재 모범 사례](https://datatracker.ietf.org/doc/html/rfc9700)
* [브라우저 기반 애플리케이션을 위한 OAuth 2.0 초안](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps)
* [OAuth 2.1 인가 프레임워크 초안](https://datatr.ietf.org/doc/html/draft-ietf-oauth-v2-1-12)

OpenID Connect에 대한 자세한 내용은 다음을 참조한다:

* [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
* [FAPI 2.0 보안 프로파일](https://openid.net/specs/fapi-security-profile-2_0-final.html)
